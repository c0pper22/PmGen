CONTEXT:
Project: ui/
  app.py
  bulk_model.py
  components.py
  factory.py
  highlighter.py
  inventory.py
  main_window.py
  theme.py
  workers.py
  __init__.py

===

==> app.py
from __future__ import annotations
import sys
import shutil
import os
import logging
from pmgen.io.http_client import get_db_path
from PyQt6.QtWidgets import QApplication
from PyQt6.QtCore import QCoreApplication

# --- NEW IMPORTS ---
from pmgen.system.diagnostics import setup_logging, install_crash_handlers

os.environ.setdefault("QT_AUTO_SCREEN_SCALE_FACTOR", "1")

def bootstrap_database():
    target_path = get_db_path()

    # =========================================================================
    # [TEMPORARY] FORCE FRESH DATABASE ON STARTUP
    # TODO: Remove the following block when you want user data to persist across sessions!
    if os.path.exists(target_path):
        try:
            os.remove(target_path)
            logging.info(f"Deleted old database at {target_path} to force a fresh copy.")
        except OSError as e:
            logging.error(f"Failed to delete old database: {e}")
    # =========================================================================

    if os.path.exists(target_path):
        return

    if getattr(sys, 'frozen', False) and hasattr(sys, '_MEIPASS'):
        base_dir = sys._MEIPASS
    elif getattr(sys, 'frozen', False):
        base_dir = os.path.dirname(sys.executable)
    else:
        base_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), "..", ".."))

    source_path = os.path.join(base_dir, "catalog_manager.db")

    if os.path.exists(source_path):
        try:
            shutil.copy2(source_path, target_path)
            logging.info(f"Successfully bootstrapped database to {target_path}")
        except Exception as e:
            logging.error(f"Error copying database: {e}")
    else:
        # Only log critical if we really needed to copy it but couldn't find the source
        logging.critical(f"Master database not found at {os.path.abspath(source_path)}")

def main() -> int:
    setup_logging()
    install_crash_handlers()

    """PmGen GUI entry point."""
    try:
        app = QApplication(sys.argv)
        QCoreApplication.setOrganizationName("PmGen")
        QCoreApplication.setOrganizationDomain("pmgen.local")
        QCoreApplication.setApplicationName("PmGen 2.0")

        bootstrap_database()

        from pmgen.ui.main_window import MainWindow, apply_static_theme
        apply_static_theme(app)

        win = MainWindow()
        win.show()

        logging.info("Application loop starting.")
        exit_code = app.exec()
        logging.info(f"Application closing with code {exit_code}")
        return exit_code

    except Exception:
        logging.exception("Critical failure during application startup.")
        raise

if __name__ == "__main__":
    raise SystemExit(main())

==> bulk_model.py
from PyQt6.QtCore import Qt, QAbstractTableModel, pyqtSignal, QModelIndex
from PyQt6.QtGui import QColor, QBrush

class BulkQueueModel(QAbstractTableModel):
    def __init__(self, parent=None):
        super().__init__(parent)
        # Added "Unpack Date" at index 3
        self.headers = ["#", "Serial", "Model", "Unpack Date", "Status", "Result"]
        self._data = []

    def rowCount(self, parent=None):
        return len(self._data)

    def columnCount(self, parent=None):
        return len(self.headers)

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if not index.isValid():
            return None

        row = index.row()
        col = index.column()

        # Internal Data Structure: [Serial, Model, UnpackDate, Status, Result]
        # Indices:                 0       1      2           3       4

        if role == Qt.ItemDataRole.DisplayRole:
            # Column 0 is the row number
            if col == 0:
                return str(row + 1)

            # Shift visual columns 1-5 to internal 0-4
            if 0 < col <= 5:
                return self._data[row][col - 1]

        # Color Logic (Status is now Visual Column 4 / Internal Index 3)
        if role == Qt.ItemDataRole.ForegroundRole and col == 4:
            status = self._data[row][3]
            if status == "Done": return QBrush(QColor("#40ed68"))       # Green
            if status == "Failed": return QBrush(QColor("#f7768e"))     # Pink/Red
            if status == "Processing": return QBrush(QColor("#7aa2f7")) # Blue
            if status == "Queued": return QBrush(QColor("#bbbbbb"))     # Grey
            if status == "Filtered": return QBrush(QColor("#d83d37"))   # Red/Orange

        return None

    def headerData(self, section, orientation, role):
        if role == Qt.ItemDataRole.DisplayRole and orientation == Qt.Orientation.Horizontal:
            return self.headers[section]
        return None

    def add_item(self, serial, model="Unknown"):
        self.beginInsertRows(QModelIndex(), len(self._data), len(self._data))
        # Initialize with empty date
        self._data.append([serial, model, "", "Queued", ""])
        self.endInsertRows()

    def update_status(self, serial, status, result, model=None, unpack_date=None):
        for i, row in enumerate(self._data):
            if row[0] == serial:
                row[3] = status
                row[4] = result

                # Update Model if provided
                if model and model != "Unknown":
                    row[1] = model

                # Update Date if provided
                if unpack_date:
                    row[2] = unpack_date

                # Notify view that the whole row changed (simple and safe)
                self.dataChanged.emit(self.index(i, 1), self.index(i, 5))
                return

    def get_serial_at(self, row):
        if 0 <= row < len(self._data):
            return self._data[row][0]
        return None

    def sort_by_status(self):
        """
        Sorts the data:
        1. Status (Done > Failed > Filtered > Queued)
        2. If Done: Sort by Percentage (Highest to Lowest)
        """
        self.beginResetModel()

        def _get_percentage(result_str):
            """Helper to extract float from strings like '85.5%'"""
            try:
                # Remove % and convert to float
                if "%" in result_str:
                    return float(result_str.replace('%', ''))
            except (ValueError, TypeError):
                pass
            return -1.0 # Fallback for non-numeric results

        def _sort_key(row):
            status = row[3]  # Internal index 3 is Status
            result = row[4]  # Internal index 4 is Result (%)

            # Primary sort key (Status Priority)
            if status == "Done":
                priority = 0
            elif status == "Failed":
                priority = 1
            elif status == "Filtered":
                priority = 2
            else:
                priority = 3

            percentage = _get_percentage(result)

            return (priority, -percentage)

        self._data.sort(key=_sort_key)
        self.endResetModel()

    def clear(self):
        self.beginResetModel()
        self._data = []
        self.endResetModel()

==> components.py
import os
from dataclasses import dataclass
from PyQt6.QtCore import Qt, QPoint, QRect
from PyQt6.QtGui import QAction, QIcon
from PyQt6.QtWidgets import (
    QWidget, QMainWindow, QLabel, QDialog, QHBoxLayout,
    QToolButton, QVBoxLayout, QFrame, QPushButton, QSizePolicy
)

# ---------------------------- Drag Helpers ----------------------------
class DragRegion(QWidget):
    def __init__(self, parent_window: QMainWindow):
        super().__init__(parent_window)
        self._win = parent_window
        self._dragging = False
        self._drag_pos = QPoint()
        self.setMinimumWidth(40)
        self.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        self.setMouseTracking(True)

    def mousePressEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = True
            self._drag_pos = e.globalPosition().toPoint() - self._win.frameGeometry().topLeft()
            e.accept()
        else:
            super().mousePressEvent(e)

    def mouseMoveEvent(self, e):
        if self._dragging:
            self._win.move(e.globalPosition().toPoint() - self._drag_pos)
            e.accept()
        else:
            super().mouseMoveEvent(e)

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = False
            e.accept()
        else:
            super().mouseReleaseEvent(e)

class TitleDragLabel(QLabel):
    def __init__(self, text: str, parent_window: QMainWindow):
        super().__init__(text, parent_window)
        self._win = parent_window
        self._dragging = False
        self._drag_pos = QPoint()
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setFixedHeight(36)
        self.setObjectName("TitleLabel")
        self.setMouseTracking(True)

    def mousePressEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = True
            self._drag_pos = e.globalPosition().toPoint() - self._win.frameGeometry().topLeft()
            e.accept()
        else:
            super().mousePressEvent(e)

    def mouseMoveEvent(self, e):
        if self._dragging and not self._win.isFullScreen():
            self._win.move(e.globalPosition().toPoint() - self._drag_pos)
            e.accept()
        else:
            super().mouseMoveEvent(e)

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = False
            e.accept()
        else:
            super().mouseReleaseEvent(e)

    def mouseDoubleClickEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = False
            if self._win.isFullScreen():
                if hasattr(self._win, "_act_full"):
                    self._win._act_full.setChecked(False)
                self._win.showNormal()
            else:
                if hasattr(self._win, "_act_full"):
                    self._win._act_full.setChecked(True)
                self._win.showFullScreen()
            e.accept()
        else:
            super().mouseDoubleClickEvent(e)

# ---------------------------- Custom TitleBar for dialogs ----------------------------
class DialogTitleBar(QWidget):
    def __init__(self, window: QDialog, title: str, icon_dir: str):
        super().__init__(window)
        self.setObjectName("DialogTitleBar")
        self._win = window
        self._dragging = False
        self._drag_pos = QPoint()

        layout = QHBoxLayout(self)
        layout.setContentsMargins(8, 6, 8, 6)
        layout.setSpacing(6)

        lbl = QLabel(title, self)
        lbl.setObjectName("DialogTitleLabel")

        btn_min = QToolButton(self); btn_min.setObjectName("DialogBtn")
        btn_min.setIcon(QIcon(os.path.join(icon_dir, "minimize.svg"))); btn_min.setToolTip("Minimize")
        btn_min.clicked.connect(self._win.showMinimized)

        self._act_max = QAction(QIcon(os.path.join(icon_dir, "fullscreen.svg")), "Maximize", self)
        self._act_max.setCheckable(True)
        self._act_max.triggered.connect(self._toggle_max_restore)
        btn_max = QToolButton(self); btn_max.setObjectName("DialogBtn")
        btn_max.setDefaultAction(self._act_max)

        btn_close = QToolButton(self); btn_close.setObjectName("DialogBtn")
        btn_close.setIcon(QIcon(os.path.join(icon_dir, "exit.svg"))); btn_close.setToolTip("Close")
        btn_close.clicked.connect(self._win.close)

        layout.addWidget(lbl, 1, Qt.AlignmentFlag.AlignVCenter)
        right = QHBoxLayout()
        right.setContentsMargins(0, 0, 0, 0)
        right.setSpacing(0)
        box = QWidget(self); box.setLayout(right)
        right.addWidget(btn_min); right.addWidget(btn_max); right.addWidget(btn_close)
        layout.addWidget(box, 0)
        self.setFixedHeight(36)

    def _toggle_max_restore(self, checked: bool):
        if checked: self._win.showMaximized()
        else: self._win.showNormal()

    def mousePressEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = True
            self._drag_pos = e.globalPosition().toPoint() - self._win.frameGeometry().topLeft()
            e.accept()
        else:
            super().mousePressEvent(e)
    def mouseMoveEvent(self, e):
        if self._dragging:
            self._win.move(e.globalPosition().toPoint() - self._drag_pos)
            e.accept()
        else:
            super().mouseMoveEvent(e)
    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton:
            self._dragging = False
            e.accept()
        else:
            super().mouseReleaseEvent(e)

# ---------------------------- FramelessDialog base ----------------------------
class FramelessDialog(QDialog):
    def __init__(self, parent, title: str, icon_dir: str):
        super().__init__(parent, flags=Qt.WindowType.FramelessWindowHint | Qt.WindowType.Tool)
        self.setObjectName("FramelessDialogRoot")
        self.setModal(True)
        outer = QVBoxLayout(self)
        outer.setContentsMargins(0, 0, 0, 0)
        outer.setSpacing(0)
        self._titlebar = DialogTitleBar(self, title, icon_dir)
        outer.addWidget(self._titlebar)
        sep = QFrame(self)
        sep.setObjectName("DialogSeparator")
        sep.setFrameShape(QFrame.Shape.NoFrame)
        outer.addWidget(sep)
        self._content = QWidget(self)
        self._content_layout = QVBoxLayout(self._content)
        self._content_layout.setContentsMargins(12, 12, 12, 12)
        self._content_layout.setSpacing(12)
        outer.addWidget(self._content)
        self.setMinimumSize(420, 220)

# ---------------------------- CustomMessageBox ----------------------------
class CustomMessageBox(FramelessDialog):
    def __init__(self, parent, title: str, text: str, icon_dir: str, buttons: list[tuple[str, str]]):
        super().__init__(parent, title, icon_dir)
        lbl = QLabel(text, self._content)
        lbl.setWordWrap(True)
        btn_row = QHBoxLayout()
        btn_row.addStretch(1)
        self._clicked_role = None
        for label, role in buttons:
            b = QPushButton(label, self._content)
            b.clicked.connect(lambda _=False, r=role: self._finish(r))
            btn_row.addWidget(b)
        self._content_layout.addWidget(lbl)
        self._content_layout.addLayout(btn_row)

    def _finish(self, role: str):
        self._clicked_role = role
        self.accept()

    @staticmethod
    def none(parent, title: str, text: str, icon_dir: str):
        dlg = CustomMessageBox(parent, title, text, icon_dir, [])
        dlg.exec()
        return dlg._clicked_role or "ok"

    @staticmethod
    def info(parent, title: str, text: str, icon_dir: str):
        dlg = CustomMessageBox(parent, title, text, icon_dir, [("OK", "ok")])
        dlg.exec()
        return dlg._clicked_role or "ok"

    @staticmethod
    def warn(parent, title: str, text: str, icon_dir: str):
        dlg = CustomMessageBox(parent, title, text, icon_dir, [("OK", "ok")])
        dlg.exec()
        return dlg._clicked_role or "ok"

    @staticmethod
    def apply(parent, title: str, text: str, icon_dir: str):
        dlg = CustomMessageBox(parent, title, text, icon_dir, [("CANCEL", "cancel"),("APPLY", "apply")])
        dlg.exec()
        return dlg._clicked_role or "ok"

    @staticmethod
    def confirm(parent, title: str, text: str, icon_dir: str):
        dlg = CustomMessageBox(parent, title, text, icon_dir, [("Cancel", "cancel"), ("OK", "ok")])
        dlg.exec()
        return dlg._clicked_role or "cancel"

@dataclass
class ResizeState:
    resizing: bool = False
    edge_left: bool = False
    edge_right: bool = False
    edge_top: bool = False
    edge_bottom: bool = False
    press_pos: QPoint = QPoint()
    press_geom: QRect = QRect()

==> factory.py
from __future__ import annotations
import os
import sys
from PyQt6.QtCore import Qt, QSize, QRegularExpression
from PyQt6.QtGui import QAction, QIcon, QRegularExpressionValidator
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QToolBar, QSizePolicy, QToolButton,
    QHBoxLayout, QLabel, QMenu, QPushButton, QComboBox,
    QCompleter, QLineEdit
)

from pmgen.system.wrappers import safe_slot
from .components import DragRegion, TitleDragLabel, CustomMessageBox
from pmgen.updater.updater import CURRENT_VERSION

BORDER_WIDTH = 8

class UIFactory:
    """
    Encapsulates the creation of complex UI bars (Toolbar, Secondary Bar)
    to keep MainWindow clean.
    """
    def __init__(self, icon_dir: str):
        self._icon_dir = icon_dir

    def create_toolbar(self, window) -> QToolBar:
        """
        Builds the main top toolbar and assigns necessary actions to the window.
        """
        tb = QToolBar("Window Controls", window)
        tb.setMovable(False)
        tb.setFloatable(False)
        tb.setContextMenuPolicy(Qt.ContextMenuPolicy.PreventContextMenu)
        tb.setContentsMargins(0, 0, 0, 0)
        tb.setMouseTracking(True)

        bar = QWidget()
        bar.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Preferred)
        bar.setMouseTracking(True)

        h = QHBoxLayout(bar)
        h.setContentsMargins(BORDER_WIDTH, BORDER_WIDTH, BORDER_WIDTH, 0)
        h.setSpacing(0)

        # --- Settings Menu ---
        settings_btn = QToolButton()
        settings_btn.setObjectName("SettingsBtn")
        settings_btn.setText("Settings ▾")
        settings_btn.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)
        settings_btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)
        settings_btn.setFixedHeight(36)

        settings_menu = QMenu(settings_btn)

        window.act_login = QAction("Login", window)
        window.act_login.triggered.connect(window._open_login_dialog)

        window.act_logout = QAction("Logout", window)
        window.act_logout.triggered.connect(window._logout)

        settings_menu.addAction(window.act_login)
        settings_menu.addAction(window.act_logout)

        act_due = QAction("Optional Threshold", window)
        act_due.triggered.connect(window._open_due_threshold_dialog)
        settings_menu.addAction(act_due)

        act_basis = QAction("Life Basis", window)
        act_basis.triggered.connect(window._open_life_basis_dialog)
        settings_menu.addAction(act_basis)

        act_show_all = QAction("Show All Items", window)
        act_show_all.setCheckable(True)
        act_show_all.setChecked(window._get_show_all())
        act_show_all.toggled.connect(window._set_show_all)
        settings_menu.addAction(act_show_all)

        act_color = QAction("Colorized Output", window)
        act_color.setCheckable(True)
        act_color.setChecked(window._get_colorized())
        act_color.toggled.connect(lambda c: (window._set_colorized(c), window._apply_colorized_highlighter()))
        settings_menu.addAction(act_color)

        act_clear = QAction("Clear Output Window", window)
        act_clear.triggered.connect(window._clear_output_window)
        settings_menu.addAction(act_clear)

        act_about = QAction("About", window)
        act_about.triggered.connect(window._show_about)
        settings_menu.addAction(act_about)

        settings_btn.setMenu(settings_menu)

        act_alerts = QAction("Enable System Alerts", window)
        act_alerts.setCheckable(True)
        act_alerts.setChecked(window._get_alerts_enabled())
        act_alerts.toggled.connect(window._set_alerts_enabled)
        settings_menu.addAction(act_alerts)

        # --- Bulk Menu ---
        bulk_btn = QToolButton()
        bulk_btn.setObjectName("BulkBtn")
        bulk_btn.setText("Bulk ▾")
        bulk_btn.setPopupMode(QToolButton.ToolButtonPopupMode.InstantPopup)
        bulk_btn.setToolButtonStyle(Qt.ToolButtonStyle.ToolButtonTextOnly)
        bulk_btn.setFixedHeight(36)

        bulk_menu = QMenu(bulk_btn)
        act_run_bulk = QAction("New Bulk Run", window)
        act_run_bulk.triggered.connect(window._start_bulk)
        act_bulk_settings = QAction("Bulk Settings", window)
        act_bulk_settings.triggered.connect(window._open_bulk_settings)
        bulk_menu.addAction(act_run_bulk)
        bulk_menu.addSeparator()
        bulk_menu.addAction(act_bulk_settings)
        bulk_btn.setMenu(bulk_menu)

        # --- Title Bar Elements ---
        # Note: We pass 'window' as parent for drag regions so they move the window
        drag_left = DragRegion(window)
        title = TitleDragLabel(f"PmGen {CURRENT_VERSION}", window)
        drag_right = DragRegion(window)

        btn_update = QToolButton()
        btn_update.setObjectName("DialogBtn")
        icon_path = os.path.join(self._icon_dir, "update.svg")
        if os.path.exists(icon_path):
            btn_update.setIcon(QIcon(icon_path))
        else:
            btn_update.setText("Update")

        btn_update.setToolTip("Check for Updates")

        if not getattr(sys, 'frozen', False):
            btn_update.clicked.connect(lambda: CustomMessageBox.info(window, "Failed", "You are not running a compiled version...", self._icon_dir))
        else:
            btn_update.clicked.connect(lambda: window._start_update_check(silent=False))

        btn_min = QToolButton()
        btn_min.setDefaultAction(QAction(QIcon(os.path.join(self._icon_dir, "minimize.svg")), "Min", window, triggered=window.showMinimized))

        window._act_full = QAction(QIcon(os.path.join(self._icon_dir, "fullscreen.svg")), "Max", window)
        window._act_full.setCheckable(True)
        window._act_full.triggered.connect(window._toggle_fullscreen)

        btn_full = QToolButton()
        btn_full.setDefaultAction(window._act_full)

        btn_exit = QToolButton()
        btn_exit.setDefaultAction(QAction(QIcon(os.path.join(self._icon_dir, "exit.svg")), "Exit", window, triggered=window._confirm_exit))

        right_box = QWidget()
        right_l = QHBoxLayout(right_box)
        right_l.setContentsMargins(0,0,0,0)
        right_l.setSpacing(0)

        right_l.addWidget(btn_update)
        right_l.addWidget(btn_min)
        right_l.addWidget(btn_full)
        right_l.addWidget(btn_exit)

        h.addWidget(settings_btn, 0)
        h.addWidget(bulk_btn, 0)
        h.addWidget(DragRegion(window), 1)
        h.addWidget(title, 0)
        h.addWidget(drag_right, 1)
        h.addWidget(right_box, 0)

        tb.addWidget(bar)
        return tb

    def create_secondary_bar(self, window) -> QWidget:
        """
        Builds the bar containing User Info, Thresholds, and the ID Input field.
        """
        bar = QWidget(window)
        bar.setObjectName("SecondaryBar")
        h = QHBoxLayout(bar)
        h.setContentsMargins(8, 6, 8, 6)
        h.setSpacing(8)

        window.user_label = QLabel("Not signed in", bar)
        window.user_label.setObjectName("UserLabel")
        h.addWidget(window.user_label, 0, Qt.AlignmentFlag.AlignVCenter)
        h.addStretch(1)

        window._thr_label = QLabel("", bar)
        window._thr_label.setObjectName("DialogLabel")

        window._basis_label = QLabel("", bar)
        window._basis_label.setObjectName("DialogLabel")

        window._update_threshold_label()
        window._update_basis_label()

        h.addWidget(window._thr_label, 0, Qt.AlignmentFlag.AlignVCenter)
        h.addWidget(window._basis_label, 0, Qt.AlignmentFlag.AlignVCenter)

        window._id_combo = QComboBox(bar)
        window._id_combo.setObjectName("IdInput")
        window._id_combo.setEditable(True)
        window._id_combo.setInsertPolicy(QComboBox.InsertPolicy.NoInsert)
        window._id_combo.setMaxVisibleItems(15)
        window._id_combo.setMinimumWidth(200)
        window._id_combo.setFixedHeight(28)

        le = window._id_combo.lineEdit()
        le.setValidator(QRegularExpressionValidator(QRegularExpression(r"[A-Za-z0-9]*"), window))
        le.textChanged.connect(window._auto_capitalize)

        completer = QCompleter(window._id_combo.model(), window._id_combo)
        completer.setFilterMode(Qt.MatchFlag.MatchContains)
        completer.setCaseSensitivity(Qt.CaseSensitivity.CaseInsensitive)
        completer.popup().setObjectName("IdCompleterPopup")
        window._id_combo.setCompleter(completer)

        window._load_id_history()

        window._generate_btn = QPushButton("Generate", bar)
        window._generate_btn.setObjectName("GenerateBtn")
        window._generate_btn.setFixedHeight(28)
        window._generate_btn.clicked.connect(window._on_generate_clicked)

        h.addWidget(window._id_combo, 0)
        h.addWidget(window._generate_btn, 0)
        return bar

==> highlighter.py
import re
from PyQt6.QtGui import QSyntaxHighlighter, QTextCharFormat, QColor, QFont
from PyQt6.QtCore import Qt

class OutputHighlighter(QSyntaxHighlighter):
    def __init__(self, parent_doc):
        super().__init__(parent_doc)

        # 1. Build Text Formats
        self._build_formats()

        # 2. Compile Regex Patterns (Performance Optimization)
        # Bulk patterns
        self.re_bulk_pct = re.compile(r"(?P<num>\d+(?:\.\d+)?)%")
        self.re_bulk_ok = re.compile(r"\bOK\b", re.IGNORECASE)
        self.re_bulk_filtered = re.compile(r"\bFILTERED\b", re.IGNORECASE)
        self.re_bulk_serial = re.compile(r"\b[A-Z0-9]{5,10}\b")

        # Kit patterns
        self.re_kit_new_after = re.compile(r"^\s*(?P<qty>\d+)\s*[x×]\s*→\s*(?P<pn>\S+)\s*→\s*(?P<kit>\S.*?)\s*$", re.IGNORECASE)
        self.re_kit_new_before = re.compile(r"^\s*x\s*(?P<qty>\d+)\s*→\s*(?P<pn>\S+)\s*→\s*(?P<kit>\S.*?)\s*$", re.IGNORECASE)
        self.re_kit_old = re.compile(r"^\s*(?P<kit>\S.*?)\s*→\s*(?P<pn>\S+)\s*[×x]\s*(?P<qty>\d+)\s*$", re.IGNORECASE)

        # Due item pattern
        self.re_due_item = re.compile(r"^\s*•\s+(?P<canon>.+?)\s+—\s+(?P<pct>\S+)(?:\s*→\s*(?P<due>DUE))?\s*$")

        # Model info pattern
        self.re_model_info = re.compile(
            r"Model:\s*(?P<model>.*?)(?=\s+\|)\s*\|\s*"
            r"Serial:\s*(?P<serial>\S+)\s*\|\s*"
            r"Last Reported:\s*(?P<report_date>.*?)(?=\s+\|)\s*\|\s*"
            r"Unpacking Date:\s*(?P<unpacking_date>.+)$"
        )

        # Threshold pattern
        self.re_threshold = re.compile(
            r"(?i)"
            r"(?P<label>due\s*threshold:)\s*"   # 'Due threshold:'
            r"(?P<thresh>[0-9.]+%?)\s*"         # '94.0%'
            r"(?P<sep>•)\s*"                    # '•'
            r"(?P<basis_lab>basis:)\s*"         # 'Basis:'
            r"(?P<basis>\S+)"                   # 'PAGE'
        )

        # Counter pattern (key: value)
        self.re_kv_pair = re.compile(r"([A-Za-z]+):\s*([0-9,]+)")

    def _mkfmt(self, fg=None, bold=False, italic=False):
        """Helper to create a QTextCharFormat."""
        fmt = QTextCharFormat()
        if fg is not None:
            fmt.setForeground(QColor(fg))
        if bold:
            fmt.setFontWeight(QFont.Weight.DemiBold)
        if italic:
            fmt.setFontItalic(True)
        return fmt

    def _build_formats(self):
        """Initialize all text styles."""
        # General Styles
        self.fmt_normal = self._mkfmt("#ffffff", bold=True)
        self.fmt_muted  = self._mkfmt("#888888", italic=True)
        self.fmt_header = self._mkfmt("#7aa2f7", bold=True)
        self.fmt_rule   = self._mkfmt("#444444")
        self.fmt_info   = self._mkfmt("#D8B30C", bold=True)
        self.fmt_label  = self._mkfmt("#c0caf5", bold=True)
        self.fmt_alert         = self._mkfmt("#ff0000", bold=True)

        # Bulk Report Styles
        self.fmt_bulk          = self._mkfmt("#a680eb", bold=True)
        self.fmt_bulk_serial   = self._mkfmt("#FFFF55", bold=True)
        self.fmt_bulk_ok       = self._mkfmt("#00ff3c", bold=True)
        self.fmt_bulk_filtered = self._mkfmt("#d83d37", bold=True)
        self.fmt_pct_low       = self._mkfmt("#40ed68", bold=True)
        self.fmt_pct_mid       = self._mkfmt("#f79346", bold=True)
        self.fmt_pct_high      = self._mkfmt("#d83d37", bold=True)

        # Kit / Part Styles
        self.fmt_kit_row = self._mkfmt("#a6da95")

        # Due Items Styles
        self.fmt_due_bullet   = self._mkfmt("#f7768e", bold=True)
        self.fmt_due_row_base = self._mkfmt("#bbbbbb")
        self.fmt_due_canon    = self._mkfmt("#1c94d5", bold=True)
        self.fmt_due_pct      = self._mkfmt("#e0af68", bold=True)
        self.fmt_due_flag     = self._mkfmt("#f7768e", bold=True)

        # Model Info Styles
        self.fmt_model_value  = self._mkfmt("#a6da95", bold=True)
        self.fmt_serial_value = self._mkfmt("#7dcfff", bold=True)
        self.fmt_r_date_value = self._mkfmt("#e0af68")
        self.fmt_u_date_value = self._mkfmt("#f77564")

        # Threshold / Badge Styles
        self.fmt_badge_line_base = self._mkfmt("#bfbfbf")
        self.fmt_thresh_value    = self._mkfmt("#fb7127", bold=True)
        self.fmt_basis_badge     = self._mkfmt("#fb7127", bold=True)

        # Counters Styles
        self.fmt_counters_base = self._mkfmt("#bfbfbf")
        self.fmt_kv_label      = self._mkfmt("#1c94d5", bold=True)
        self.fmt_kv_value      = self._mkfmt("#e0af68", bold=True)

    def highlightBlock(self, text: str):
        """Main entry point for syntax highlighting."""
        # 1. Apply base normal format to the whole line
        self.setFormat(0, len(text), self.fmt_normal)

        t = text.strip()
        if not t:
            return

        # --- Priority Tags ---
        if "[Auto-Login]" in t:
            self.setFormat(0, len(text), self.fmt_muted)
            return

        if "[Info]" in t:
            self.setFormat(0, len(text), self.fmt_info)
            # We don't return here as [Info] might have other content,
            # though usually it's standalone. If standalone, add 'return'.

        # --- Bulk Handling (Complex Logic) ---
        if "[Bulk]" in t:
            self._highlight_bulk_line(text, t)
            return

        # --- Unpack Alert ---
        if "[!] Unpacking Date Alert:" in t:
            self.setFormat(0, len(text), self.fmt_alert)
            return

        # --- Standard Headers & Rules ---
        if t in ("Final Parts", "Most-Due Items", "Counters", "End of Report"):
            self.setFormat(0, len(text), self.fmt_header)
            return

        # Check for horizontal rules (e.g. "----", "====")
        # Checks if all unique characters in the string are part of the rule set
        unique_chars = set(t)
        if unique_chars == {"─"} or unique_chars == {"-"} or unique_chars == {"="}:
            self.setFormat(0, len(text), self.fmt_rule)
            return

        # --- Muted / specific prefixes ---
        t_lower = t.lower()
        if t.startswith("(") and any(tok in t_lower for tok in ("qty", "catalog", "part number", "×", " x ")):
            self.setFormat(0, len(text), self.fmt_muted)
            return

        # --- Kit / Part Rows ---
        if "→" in t and not t.startswith("Report Date"):
            if (self.re_kit_new_after.match(t) or
                self.re_kit_new_before.match(t) or
                self.re_kit_old.match(t)):
                self.setFormat(0, len(text), self.fmt_kit_row)
                return

        # --- Due Items / Bullets ---
        if t.startswith("• ") or "→ DUE" in t:
            self._highlight_due_item(text, t)
            return

        # --- Model Info Block ---
        if t.startswith("Model:") and "Serial:" in t:
            self._highlight_model_info(text)
            return

        # --- Labels ---
        if t.startswith("Basis:") or t.startswith("Report Date:"):
            self.setFormat(0, len(text), self.fmt_label)
            return

        # --- Thresholds ---
        if t_lower.startswith("due threshold:") and "basis:" in t_lower:
            self._highlight_threshold(text)
            return

        # --- Counters ---
        if t_lower.startswith("color:") or (" black:" in t_lower and " total:" in t_lower):
            self._highlight_counters(text)
            return

    def _highlight_bulk_line(self, text, stripped):
        """Handles specific formatting for lines containing [Bulk]."""
        # 1. Color the [Bulk] tag itself
        tag_bulk = "[Bulk]"
        start_index = text.find(tag_bulk)
        if start_index >= 0:
            self.setFormat(start_index, len(tag_bulk), self.fmt_bulk)

        # 2. Color Percentages based on value
        for m in self.re_bulk_pct.finditer(stripped):
            try:
                val = float(m.group("num"))
                if val < 84.0:
                    fmt = self.fmt_pct_low
                elif val < 100.0:
                    fmt = self.fmt_pct_mid
                else:
                    fmt = self.fmt_pct_high
                self.setFormat(m.start(), m.end() - m.start(), fmt)
            except ValueError:
                continue

        # 3. Status Keywords
        for m in self.re_bulk_ok.finditer(stripped):
            self.setFormat(m.start(), m.end() - m.start(), self.fmt_bulk_ok)

        for m in self.re_bulk_filtered.finditer(stripped):
            self.setFormat(m.start(), m.end() - m.start(), self.fmt_bulk_filtered)

        # 4. Serial Numbers
        for m in self.re_bulk_serial.finditer(stripped):
            self.setFormat(m.start(), m.end() - m.start(), self.fmt_bulk_serial)

    def _highlight_due_item(self, text, stripped):
        """Handles lines with bullets or DUE flags."""
        m = self.re_due_item.match(stripped)
        if m:
            # Overwrite the base white with the grey base
            self.setFormat(0, len(text), self.fmt_due_row_base)

            # Calculate whitespace offset because regex matched on stripped text
            left_ws = len(text) - len(text.lstrip())

            def _apply(name, fmt):
                if m.group(name):
                    s, e = m.start(name), m.end(name)
                    self.setFormat(left_ws + s, e - s, fmt)

            _apply("canon", self.fmt_due_canon)
            _apply("pct",   self.fmt_due_pct)
            if m.group("due"):
                _apply("due", self.fmt_due_flag)
        else:
            self.setFormat(0, len(text), self.fmt_due_bullet)

    def _highlight_model_info(self, text):
        """Handles the Model | Serial | Date line."""
        m = self.re_model_info.search(text)
        if m:
            self.setFormat(m.start("model"), m.end("model") - m.start("model"), self.fmt_model_value)
            self.setFormat(m.start("serial"), m.end("serial") - m.start("serial"), self.fmt_serial_value)
            self.setFormat(m.start("report_date"), m.end("report_date") - m.start("report_date"), self.fmt_r_date_value)
            self.setFormat(m.start("unpacking_date"), m.end("unpacking_date") - m.start("unpacking_date"), self.fmt_u_date_value)

    def _highlight_threshold(self, text):
        """Handles the Due Threshold line with granular coloring."""
        m = self.re_threshold.search(text)
        if m:
            self.setFormat(*m.span("thresh"), self.fmt_thresh_value)
            self.setFormat(*m.span("sep"), self.fmt_normal)
            self.setFormat(*m.span("basis_lab"), self.fmt_normal)
            self.setFormat(*m.span("basis"), self.fmt_basis_badge)

    def _highlight_counters(self, text):
        """Handles Key:Value lines (Colors, counts)."""
        self.setFormat(0, len(text), self.fmt_counters_base)
        for m in self.re_kv_pair.finditer(text):
            self.setFormat(*m.span(1), self.fmt_kv_label)
            self.setFormat(*m.span(2), self.fmt_kv_value)

==> inventory.py
import os
import io
import numpy as np
import pandas as pd
import logging
from pmgen.system.wrappers import safe_slot
from PyQt6.QtCore import Qt, QAbstractTableModel, QStandardPaths, QModelIndex
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QTableView, QFileDialog, QHeaderView, QApplication, QMessageBox
)

from .components import CustomMessageBox

def get_cache_path():
    """Returns the standardized path to the inventory CSV."""
    base_dir = QStandardPaths.writableLocation(QStandardPaths.StandardLocation.AppDataLocation)
    if not os.path.exists(base_dir):
        os.makedirs(base_dir)
    return os.path.join(base_dir, "inventory_cache.csv")

def load_inventory_cache() -> pd.DataFrame:
    """
    Loads the inventory dataframe from disk.
    Used by both the UI and the Rules Engine.
    """
    path = get_cache_path()
    if not os.path.exists(path):
        return pd.DataFrame()

    try:
        df = pd.read_csv(path)
        # Ensure numeric types for calculation
        if "Quantity" in df.columns:
            df["Quantity"] = pd.to_numeric(df["Quantity"], errors='coerce').fillna(0)

        # Clean up string columns for matching
        if "Part Number" in df.columns:
            df["Part Number"] = df["Part Number"].astype(str).str.strip().str.upper()
        if "Unit Name" in df.columns:
            df["Unit Name"] = df["Unit Name"].astype(str).str.strip().str.upper()

        return df
    except Exception as e:
        print(f"Error loading inventory cache: {e}")
        return pd.DataFrame()

class InventoryModel(QAbstractTableModel):
    """
    A custom model to display the Pandas DataFrame in a QTableView.
    Now supports editing, row deletion, and adding rows.
    """
    def __init__(self, data=None):
        super().__init__()
        self._df = data if data is not None else pd.DataFrame()
        # Define default columns in case the app starts empty
        self.default_columns = ['Part Number', 'Unit Name', 'Quantity', 'Unit Cost', 'Total Cost']

    def rowCount(self, parent=None):
        return self._df.shape[0]

    def columnCount(self, parent=None):
        return self._df.shape[1]

    def data(self, index, role=Qt.ItemDataRole.DisplayRole):
        if index.isValid():
            if role == Qt.ItemDataRole.DisplayRole or role == Qt.ItemDataRole.EditRole:
                # Handle empty dataframe edge case
                if self._df.empty:
                    return None

                val = self._df.iloc[index.row(), index.column()]

                # If editing, return raw number (no formatting)
                if role == Qt.ItemDataRole.EditRole:
                    return str(val)

                # Format currency columns for display
                col_name = self._df.columns[index.column()]
                if isinstance(val, (float, int)) and ("Cost" in col_name):
                    return f"${val:,.2f}"
                return str(val)
        return None

    def headerData(self, section, orientation, role):
        if role == Qt.ItemDataRole.DisplayRole:
            if orientation == Qt.Orientation.Horizontal:
                if self._df.empty and section < len(self.default_columns):
                    return self.default_columns[section]
                return self._df.columns[section]
            if orientation == Qt.Orientation.Vertical:
                return str(section + 1)
        return None

    def flags(self, index):
        """
        Determines if a cell is editable.
        """
        if not index.isValid():
            return Qt.ItemFlag.NoItemFlags

        base_flags = Qt.ItemFlag.ItemIsEnabled | Qt.ItemFlag.ItemIsSelectable

        # Check which column this is
        col_name = self._df.columns[index.column()]

        # Prevent editing of "Total Cost" (Calculated field)
        if col_name not in ["Total Cost"]:
            return base_flags | Qt.ItemFlag.ItemIsEditable

        return base_flags

    def setData(self, index, value, role=Qt.ItemDataRole.EditRole):
        """
        Saves user input to the DataFrame and recalculates math.
        """
        if index.isValid() and role == Qt.ItemDataRole.EditRole:
            row = index.row()
            col = index.column()
            col_name = self._df.columns[col]

            # 1. Clean the input
            clean_val = value
            if isinstance(value, str):
                clean_val = value.replace('$', '').replace(',', '').strip()

            # 2. Convert data types based on column
            try:
                if col_name in ["Quantity"]:
                    self._df.iloc[row, col] = float(clean_val)
                elif "Cost" in col_name:
                    self._df.iloc[row, col] = float(clean_val)
                else:
                    self._df.iloc[row, col] = str(clean_val)
            except ValueError:
                return False

            # 3. Recalculate Total Cost
            if col_name in ["Quantity", "Unit Cost"]:
                try:
                    qty = float(self._df.iloc[row, self._df.columns.get_loc("Quantity")])
                    cost = float(self._df.iloc[row, self._df.columns.get_loc("Unit Cost")])

                    if "Total Cost" in self._df.columns:
                        ext_idx = self._df.columns.get_loc("Total Cost")
                        new_ext = qty * cost
                        self._df.iloc[row, ext_idx] = new_ext

                        ext_model_idx = self.index(row, ext_idx)
                        self.dataChanged.emit(ext_model_idx, ext_model_idx, [Qt.ItemDataRole.DisplayRole])
                except Exception:
                    pass

            self.dataChanged.emit(index, index, [Qt.ItemDataRole.DisplayRole, Qt.ItemDataRole.EditRole])
            return True

        return False

    def remove_rows(self, rows_to_delete):
        """
        Removes rows from the dataframe by index list.
        """
        if not rows_to_delete:
            return

        self.beginResetModel()
        # Drop rows by index
        self._df.drop(self._df.index[rows_to_delete], inplace=True)
        # Reset index so 0..N is continuous again
        self._df.reset_index(drop=True, inplace=True)
        self.endResetModel()

    def add_row(self):
        """
        Adds a new blank row to the bottom of the DataFrame.
        """
        # If the dataframe is empty, initialize it with default columns
        if self._df.empty:
            self._df = pd.DataFrame(columns=self.default_columns)
            # Notify view that columns have changed (headers appear)
            self.headerDataChanged.emit(Qt.Orientation.Horizontal, 0, len(self.default_columns)-1)

        # Create a default row dictionary
        new_row_data = {}
        for col in self._df.columns:
            if "Quantity" in col:
                new_row_data[col] = 0.0
            elif "Cost" in col:
                new_row_data[col] = 0.0
            else:
                new_row_data[col] = "New Item" if col == "Part Number" else ""

        # Calculate insertion index
        idx = len(self._df)

        # Notify View we are adding 1 row
        self.beginInsertRows(QModelIndex(), idx, idx)

        # Create small DF for the new row and append it
        new_row_df = pd.DataFrame([new_row_data])

        # Use concat as append is deprecated in newer pandas versions
        self._df = pd.concat([self._df, new_row_df], ignore_index=True)

        self.endInsertRows()

    def update_data(self, df):
        self.beginResetModel()
        self._df = df
        self.endResetModel()

    def get_dataframe(self):
        return self._df

class InventoryTab(QWidget):
    """
    The widget that lives inside the 'Tools' tab.
    Handles loading, cleaning, displaying, persisting, and deleting inventory items.
    """
    def __init__(self, parent=None, icon_dir=None):
        super().__init__(parent)
        self._layout = QVBoxLayout(self)
        self._layout.setContentsMargins(8, 8, 8, 8)
        self._layout.setSpacing(8)
        self.icon_dir = icon_dir

        # 1. Top Controls Area
        top_bar = QHBoxLayout()

        self.btn_load = QPushButton("Import")
        self.btn_load.setToolTip("Import Inventory CSV")
        self.btn_load.setIcon(QIcon.fromTheme("document-open"))
        self.btn_load.clicked.connect(self._load_csv)
        self.btn_load.setFixedHeight(32)

        self.btn_add = QPushButton("Add Item")
        self.btn_add.setToolTip("Add a new empty row")
        self.btn_add.setIcon(QIcon.fromTheme("list-add"))
        self.btn_add.clicked.connect(self._add_new_row)
        self.btn_add.setFixedHeight(32)

        self.btn_delete = QPushButton("Delete")
        self.btn_delete.setToolTip("Delete selected rows")
        self.btn_delete.setIcon(QIcon.fromTheme("edit-delete"))
        self.btn_delete.clicked.connect(self._delete_selected)
        self.btn_delete.setFixedHeight(32)

        self.lbl_status = QLabel("No inventory loaded")
        self.lbl_status.setStyleSheet("color: #888; font-style: italic;")

        self.lbl_total = QLabel("Total Value: $0.00")
        self.lbl_total.setStyleSheet("font-weight: bold; color: #4CAF50;")

        top_bar.addWidget(self.btn_load)
        top_bar.addWidget(self.btn_add)     # Added here
        top_bar.addWidget(self.btn_delete)
        top_bar.addWidget(self.lbl_status)
        top_bar.addStretch(1)
        top_bar.addWidget(self.lbl_total)

        # 2. Table Area
        self.table_view = QTableView()
        self.model = InventoryModel()
        self.table_view.setModel(self.model)

        # Connect data changes (Edit)
        self.model.dataChanged.connect(self._recalculate_total_label)
        self.model.dataChanged.connect(self._auto_save_to_cache)

        # Connect model reset (Load new file, Delete rows, Add rows)
        self.model.modelReset.connect(self._recalculate_total_label)
        self.model.modelReset.connect(self._auto_save_to_cache)
        self.model.rowsInserted.connect(self._auto_save_to_cache) # Save on add

        # Style the table
        self.table_view.setAlternatingRowColors(True)
        self.table_view.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.table_view.setSelectionMode(QTableView.SelectionMode.ExtendedSelection) # Allow multiple selection
        self.table_view.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.table_view.verticalHeader().setVisible(False)
        self.table_view.setShowGrid(False)

        self._layout.addLayout(top_bar)
        self._layout.addWidget(self.table_view)

        # 3. Attempt to restore previous session data
        self._load_from_cache()

    @safe_slot
    def _add_new_row(self, *args):
        """
        Adds a row to the model and scrolls to it.
        """
        self.model.add_row()
        self.lbl_status.setText("Added new item")
        # Scroll to bottom
        self.table_view.scrollToBottom()

    @safe_slot
    def _delete_selected(self, *args):
        """
        Gets the selected rows from the view and asks the model to remove them.
        """
        selection = self.table_view.selectionModel().selectedRows()
        if not selection:
            CustomMessageBox.info(self, "No Selection", "Please select row(s) to delete.", "")
            return

        # Ask for confirmation
        count = len(selection)
        confirm = CustomMessageBox.confirm(
            self,
            "Delete Rows",
            f"Are you sure you want to delete {count} row(s)?",
            self.icon_dir
        )

        if confirm == "ok":
            # Get the row indices
            rows_to_delete = [index.row() for index in selection]
            # Remove them (model handles sort/reset)
            self.model.remove_rows(rows_to_delete)
            self.lbl_status.setText(f"Deleted {count} item(s)")

    def _get_cache_path(self):
        base_dir = QStandardPaths.writableLocation(QStandardPaths.StandardLocation.AppDataLocation)
        if not os.path.exists(base_dir):
            os.makedirs(base_dir)
        return os.path.join(base_dir, "inventory_cache.csv")

    def _auto_save_to_cache(self):
        df = self.model.get_dataframe()
        if df is not None:
            try:
                path = self._get_cache_path()
                df.to_csv(path, index=False)
            except Exception as e:
                print(f"Failed to autosave inventory: {e}")

    def _load_from_cache(self):
        path = self._get_cache_path()
        if os.path.exists(path):
            try:
                df = pd.read_csv(path)
                # Ensure numeric types
                if "Quantity" in df.columns:
                    df["Quantity"] = pd.to_numeric(df["Quantity"], errors='coerce').fillna(0)
                if "Unit Cost" in df.columns:
                    df["Unit Cost"] = pd.to_numeric(df["Unit Cost"], errors='coerce').fillna(0.0)
                if "Total Cost" in df.columns:
                    df["Total Cost"] = pd.to_numeric(df["Total Cost"], errors='coerce').fillna(0.0)

                self.model.update_data(df)
                self.lbl_status.setText("Restored previous session")
                self.table_view.resizeColumnsToContents()
            except Exception:
                pass

    def _recalculate_total_label(self):
        df = self.model.get_dataframe()
        if df is not None and not df.empty and "Total Cost" in df.columns:
            total_val = df['Total Cost'].sum()
            self.lbl_total.setText(f"Total Value: ${total_val:,.2f}")
        else:
            self.lbl_total.setText("Total Value: $0.00")

    @safe_slot
    def _load_csv(self, *args):
        path, _ = QFileDialog.getOpenFileName(self, "Open Inventory CSV", "", "CSV Files (*.csv);;All Files (*.*)")
        if not path:
            return

        try:
            self.lbl_status.setText("Processing...")
            QApplication.processEvents()
            clean_df = self._process_messy_csv(path)

            if clean_df is not None and not clean_df.empty:
                self.model.update_data(clean_df)
                self.lbl_status.setText(f"Loaded: {os.path.basename(path)}")
                self.table_view.resizeColumnsToContents()
                self.table_view.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
                self.table_view.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.Stretch)
            else:
                self.lbl_status.setText("Error: No data found")

        except Exception as e:
            CustomMessageBox.warn(self, "Import Failed", f"Could not process file:\n{str(e)}", "")
            self.lbl_status.setText("Import Failed")

    def _process_messy_csv(self, file_path):
        # 1. Read file and filter lines
        valid_lines = []
        with open(file_path, 'r', encoding='utf-8', errors='replace') as f:
            for line in f:
                if line.strip().startswith('","'):
                    valid_lines.append(line)

        if not valid_lines:
            raise ValueError("File format not recognized (no valid data rows).")

        clean_csv_string = "\n".join(valid_lines)
        df = pd.read_csv(io.StringIO(clean_csv_string), header=None)

        clean_df = pd.DataFrame()
        is_layout_a = df[6].notnull()

        clean_df['Part Number']   = np.where(is_layout_a, df[6], df[11])
        clean_df['Unit Name']   = np.where(is_layout_a, df[7], df[12])
        clean_df['Quantity']      = np.where(is_layout_a, df[8], df[13])
        clean_df['Unit Cost']     = np.where(is_layout_a, df[9], df[14])

        def clean_money(val):
            if isinstance(val, str):
                val = val.replace('$', '').replace(',', '')
                try: return float(val)
                except: return 0.0
            return val if isinstance(val, (int, float)) else 0.0

        clean_df['Unit Cost'] = clean_df['Unit Cost'].apply(clean_money)
        clean_df['Quantity'] = pd.to_numeric(clean_df['Quantity'], errors='coerce').fillna(0)
        clean_df['Total Cost'] = clean_df['Quantity'] * clean_df['Unit Cost']

        clean_df = clean_df.dropna(subset=['Part Number'])
        return clean_df

==> main_window.py
from __future__ import annotations
import sys, os, re
import shutil
import requests
import logging
from collections import deque
from datetime import datetime
from PyQt6.QtCore import (
    Qt, QSize, QPoint, QRect, QEvent, QRegularExpression,
    QCoreApplication, QSettings, QThread, pyqtSlot, QTimer, pyqtSignal
)
from PyQt6.QtGui import (
    QAction, QIcon, QCursor, QRegularExpressionValidator, QKeySequence,
    QShortcut, QTextCursor
)
from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QPlainTextEdit,
    QToolBar, QSizePolicy, QToolButton, QHBoxLayout, QLabel, QMenu,
    QPushButton, QLineEdit, QComboBox, QCheckBox, QSlider,
    QSpinBox, QDoubleSpinBox, QFileDialog, QProgressBar, QCompleter,
    QTabWidget, QTableView, QHeaderView, QSplitter, QTabBar
)

# Imports from our new split files
from pmgen.ui.bulk_model import BulkQueueModel
from pmgen.system.wrappers import safe_slot
from .theme import apply_static_theme
from .components import (
    DragRegion, TitleDragLabel, FramelessDialog, CustomMessageBox, ResizeState
)
from .highlighter import OutputHighlighter
from .workers import BulkConfig, BulkRunner
from pmgen.updater.updater import UpdateWorker, perform_restart, CURRENT_VERSION
from .inventory import InventoryTab
from .factory import UIFactory

SERVICE_NAME = "PmGen"

# Constants
BORDER_WIDTH = 8
BULK_TOPN_KEY = "bulk/top_n"
BULK_DIR_KEY  = "bulk/out_dir"
BULK_POOL_KEY = "bulk/pool_size"
BULK_BLACKLIST_KEY = "bulk/blacklist"

# =============================================================================
#  NEW CLASS: BulkRunTab
#  Encapsulates a single bulk run (UI + Logic + Thread)
# =============================================================================
class BulkRunTab(QWidget):
    """
    A self-contained tab for a single bulk processing job.
    Owms its own model, view, and worker thread.
    """
    inspect_requested = pyqtSignal(str)  # Signal back to MainWindow to inspect a serial
    finished = pyqtSignal()              # Signal when run is complete

    def __init__(self, config: BulkConfig, runner_kwargs: dict, parent=None):
        super().__init__(parent)
        self.config = config
        self.runner_kwargs = runner_kwargs

        self._thread: QThread | None = None
        self._runner: BulkRunner | None = None
        self._is_running = False

        self._setup_ui()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        layout.setSpacing(6)

        # --- Top Bar: Progress & Status ---
        top_bar = QHBoxLayout()

        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("font-weight: bold; color: #bbbbbb;")

        self.progress_bar = QProgressBar()
        self.progress_bar.setObjectName("ProgressBar")
        self.progress_bar.setFixedHeight(12)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(False)

        top_bar.addWidget(self.status_label)
        top_bar.addWidget(self.progress_bar, 1)

        # Add a "Stop" button
        self.btn_stop = QPushButton("Stop")
        self.btn_stop.setObjectName("BulkStopBtn")
        self.btn_stop.setFixedHeight(24)
        self.btn_stop.clicked.connect(self.stop)
        self.btn_stop.setEnabled(False) # Enabled when running
        top_bar.addWidget(self.btn_stop)

        layout.addLayout(top_bar)

        # --- Splitter: Table & Logs ---
        splitter = QSplitter(Qt.Orientation.Vertical)

        # 1. The Table
        self.view = QTableView()
        self.model = BulkQueueModel()
        self.view.setModel(self.model)
        self.view.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeMode.Stretch)
        self.view.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        self.view.setSelectionBehavior(QTableView.SelectionBehavior.SelectRows)
        self.view.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.view.customContextMenuRequested.connect(self._on_context_menu)

        splitter.addWidget(self.view)

        # 2. Local Log Window (so user sees errors for *this* run)
        self.log_editor = QPlainTextEdit()
        self.log_editor.setObjectName("MainEditor")
        self.log_editor.setReadOnly(True)
        self.log_editor.setMaximumBlockCount(1000)
        self.log_editor.setPlaceholderText("Run logs will appear here...")
        splitter.addWidget(self.log_editor)

        # Set initial sizes (Table gets most space)
        splitter.setSizes([400, 50])

        layout.addWidget(splitter, 1)

    def start(self):
        if self._is_running: return

        self.model.clear()
        self.log_editor.clear()
        self.btn_stop.setEnabled(True)
        self.status_label.setText("Initializing...")

        # Create Thread & Runner
        self._thread = QThread()
        self._runner = BulkRunner(self.config, **self.runner_kwargs)
        self._runner.moveToThread(self._thread)

        # Connect Signals
        self._thread.started.connect(self._runner.run)

        self._runner.progress.connect(self._on_progress_text)
        self._runner.progress_value.connect(self._on_progress_value)
        self._runner.item_updated.connect(self._on_item_updated)
        self._runner.finished.connect(self._on_finished)

        # Cleanup signals
        self._runner.finished.connect(self._thread.quit)
        self._runner.finished.connect(self._runner.deleteLater)
        self._thread.finished.connect(self._thread.deleteLater)
        self._thread.finished.connect(self._on_thread_gone)

        self._thread.start()
        self._is_running = True

    def stop(self):
        if self._is_running and self._thread:
            self._log("[Info] Stop requested... (this may take a moment to finish current tasks)")
            self._thread.requestInterruption()
            self.btn_stop.setEnabled(False)

    @safe_slot
    def _on_context_menu(self, pos):
        index = self.view.indexAt(pos)
        if not index.isValid(): return

        serial = self.model.get_serial_at(index.row())

        menu = QMenu(self.view)
        act_inspect = QAction("Inspect / Generate Single Report", self.view)
        act_inspect.triggered.connect(lambda: self.inspect_requested.emit(serial))
        menu.addAction(act_inspect)

        menu.exec(self.view.viewport().mapToGlobal(pos))

    def _open_folder(self):
        if self.config.out_dir and os.path.exists(self.config.out_dir):
            os.startfile(self.config.out_dir)

    # --- Worker Slots ---

    @pyqtSlot(str)
    def _on_progress_text(self, text):
        self._log(text)
        if text.startswith("[Bulk]"):
            clean = text.replace("[Bulk]", "").strip()
            self.status_label.setText(clean)
        elif text.startswith("[Info]"):
            clean = text.replace("[Info]", "").strip()
            self.status_label.setText(clean)

    @pyqtSlot(int, int)
    def _on_progress_value(self, current, total):
        self.progress_bar.setMaximum(total)
        self.progress_bar.setValue(current)

    @pyqtSlot(str, str, str, str, str)
    def _on_item_updated(self, serial, status, result, model, unpack_date):
        found = False
        for r in range(self.model.rowCount()):
            if self.model.get_serial_at(r) == serial:
                self.model.update_status(serial, status, result, model, unpack_date)
                found = True
                break

        if not found:
            self.model.add_item(serial, model)
            self.model.update_status(serial, status, result, model, unpack_date)

    @pyqtSlot(str)
    def _on_finished(self, msg):
        self._log(msg)
        self.status_label.setText("Done")
        self.progress_bar.setValue(self.progress_bar.maximum())
        self.model.sort_by_status()
        self.btn_stop.setEnabled(False)
        self.finished.emit()

    def _on_thread_gone(self):
        self._thread = None
        self._runner = None
        self._is_running = False

    def _log(self, text):
        self.log_editor.appendPlainText(text)
        self.log_editor.moveCursor(QTextCursor.MoveOperation.End)

# =============================================================================
#  MAIN WINDOW
# =============================================================================

class MainWindow(QMainWindow):
    # ---- PM settings Keys ----
    THRESH_KEY = "pm/due_threshold"
    THRESH_ENABLED_KEY = "pm/due_threshold_enabled"
    LIFE_BASIS_KEY = "pm/life_basis"
    COLORIZED_KEY = "ui/colorized_output"
    SHOW_ALL_KEY = "ui/show_all_items"
    ALERTS_ENABLED_KEY = "ui/alerts_enabled"

    BULK_UNPACK_KEY_ENABLE = "bulk/unpack_filter_enabled"
    BULK_UNPACK_KEY_EXTRA  = "bulk/unpack_extra_months"

    # ---- Auth prefs Keys ----
    AUTH_REMEMBER_KEY = "auth/remember"
    AUTH_USERNAME_KEY = "auth/username"
    HISTORY_KEY = "recent_serials"
    MAX_HISTORY = 25

    sig_start_download = pyqtSignal(str)
    sig_start_extract = pyqtSignal(str)

    def __init__(self):
        super().__init__()
        self.setWindowTitle("PmGen")
        self.resize(1100, 720)
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint | Qt.WindowType.Window)

        if getattr(sys, 'frozen', False):
                import glob
                current_dir = os.path.dirname(sys.executable)
                # Look for any file containing ".old."
                for p in glob.glob(os.path.join(current_dir, "*.old*")):
                    try:
                        if os.path.isdir(p):
                            shutil.rmtree(p)
                        else:
                            os.remove(p)
                    except OSError:
                        pass

        # Paths
        if getattr(sys, "frozen", False) and hasattr(sys, "_MEIPASS"):
            base_dir = sys._MEIPASS
        else:
            base_dir = os.path.dirname(os.path.dirname(os.path.dirname(__file__)))
        self._icon_dir = os.path.join(base_dir, "pmgen", "assets", "icons")

        # Auth UI state
        self._signed_in: bool = False
        self._current_user: str = ""
        self._auto_login_attempted: bool = False
        self._session = None

        # Global tracking + event filter
        app = QApplication.instance()
        app.installEventFilter(self)
        self.setMouseTracking(True)

        # --- UI SETUP START ---
        central = QWidget()
        self.setCentralWidget(central)
        central.setMouseTracking(True)

        # Main layout for the window
        self._vbox = QVBoxLayout(central)
        self._vbox.setContentsMargins(6, 6, 6, 6)
        self._vbox.setSpacing(0)

        # Initialize the Tab Widget
        self.tabs = QTabWidget()
        self.tabs.setObjectName("MainTabs")
        self.tabs.setDocumentMode(True)
        self.tabs.setTabsClosable(True) # ENABLE TAB CLOSING
        self.tabs.tabCloseRequested.connect(self._on_tab_close_requested)
        self._vbox.addWidget(self.tabs)

        # -- TAB 1: Home (Cleaned up: Just Editor and Bar) --
        self.tab_home = QWidget()
        self.tab_home.setObjectName("TabHome")
        home_layout = QVBoxLayout(self.tab_home)
        home_layout.setContentsMargins(0, 8, 0, 0)
        home_layout.setSpacing(6)

        # --- REFACTOR: Use UIFactory ---
        ui_factory = UIFactory(self._icon_dir)
        self._secondary_bar = ui_factory.create_secondary_bar(self)
        home_layout.addWidget(self._secondary_bar, 0)

        self.editor = QPlainTextEdit()
        self.editor.setReadOnly(True)
        self.editor.setMaximumBlockCount(2000)
        self._apply_colorized_highlighter()
        self.editor.setObjectName("MainEditor")
        self.editor.setLineWrapMode(QPlainTextEdit.LineWrapMode.NoWrap)

        home_layout.addWidget(self.editor, 1)

        self.tabs.addTab(self.tab_home, "Single")
        self.tabs.tabBar().setTabButton(0, QTabBar.ButtonPosition.RightSide, None)

        self.tab_tools = InventoryTab(self, icon_dir=self._icon_dir)
        self.tab_tools.setObjectName("TabInventory")
        self.tabs.addTab(self.tab_tools, "Inventory")

        self.tabs.tabBar().setTabButton(1, QTabBar.ButtonPosition.RightSide, None)

        # --- REFACTOR: Use UIFactory ---
        self.toolbar = ui_factory.create_toolbar(self)
        self.addToolBar(Qt.ToolBarArea.TopToolBarArea, self.toolbar)

        # UPDATER STATE
        self._update_thread: QThread | None = None
        self._update_worker: UpdateWorker | None = None
        self._update_silent_mode = False

        # Shortcuts
        clear_shortcut = QShortcut(QKeySequence("Ctrl+L"), self)
        clear_shortcut.activated.connect(self._clear_output_window)
        generate_shortcut = QShortcut(QKeySequence("Return"), self)
        generate_shortcut.activated.connect(self._on_generate_clicked)

        self._update_auth_ui()
        QTimer.singleShot(0, self._attempt_auto_login)

        # --- AUTO CHECK ON STARTUP ---
        QTimer.singleShot(1500, lambda: self._start_update_check(silent=True))

        self._rs = ResizeState()

    # =========================================================================
    #  Tab Management
    # =========================================================================

    def _on_tab_close_requested(self, index):
        # Don't allow closing Home (0) or Inventory (1)
        # Adjust indices if you rearrange tabs.
        widget = self.tabs.widget(index)

        if widget == self.tab_home or widget == self.tab_tools:
            return # Ignore

        if isinstance(widget, BulkRunTab):
            # Check if running
            if widget._is_running:
                res = CustomMessageBox.confirm(
                    self, "Job Running",
                    "This bulk job is still running.\nAre you sure you want to stop and close it?",
                    self._icon_dir
                )
                if res != "ok": return
                widget.stop()

            self.tabs.removeTab(index)
            widget.deleteLater()

    # =========================================================================
    #  Settings Management
    # =========================================================================

    def _get_alerts_enabled(self) -> bool:
        return bool(QSettings().value(self.ALERTS_ENABLED_KEY, True, bool))

    def _set_alerts_enabled(self, on: bool):
        QSettings().setValue(self.ALERTS_ENABLED_KEY, bool(on))

    def _get_unpack_filter_enabled(self) -> bool:
        return bool(QSettings().value(self.BULK_UNPACK_KEY_ENABLE, False, bool))

    def _get_unpack_extra_months(self) -> int:
        try: v = int(QSettings().value(self.BULK_UNPACK_KEY_EXTRA, 0, int))
        except: v = 0
        return max(0, min(120, v))

    def _get_bulk_config(self) -> BulkConfig:
        s = QSettings()
        top_n = int(s.value(BULK_TOPN_KEY, 25, int))
        out   = s.value(BULK_DIR_KEY, "", str)
        pool  = int(s.value(BULK_POOL_KEY, 4, int))
        bl_raw = s.value(BULK_BLACKLIST_KEY, "", str) or ""
        bl = [line.strip().upper() for line in re.split(r"[,\n]+", bl_raw) if line.strip()]
        return BulkConfig(top_n=max(1, min(9999, top_n)), out_dir=out, pool_size=max(1, min(16, pool)), blacklist=bl)

    def _save_bulk_config(self, cfg: BulkConfig):
        s = QSettings()
        s.setValue(BULK_TOPN_KEY, int(cfg.top_n))
        s.setValue(BULK_DIR_KEY, cfg.out_dir or "")
        s.setValue(BULK_POOL_KEY, int(cfg.pool_size))
        s.setValue(BULK_BLACKLIST_KEY, "\n".join(cfg.blacklist or []))

    def _get_show_all(self) -> bool:
        return bool(QSettings().value(self.SHOW_ALL_KEY, False, bool))

    def _set_show_all(self, on: bool):
        QSettings().setValue(self.SHOW_ALL_KEY, bool(on))

    def _get_colorized(self) -> bool:
        return bool(QSettings().value(self.COLORIZED_KEY, True, bool))

    def _set_colorized(self, on: bool):
        QSettings().setValue(self.COLORIZED_KEY, bool(on))

    def _get_threshold(self) -> float:
        try: v = float(QSettings().value(self.THRESH_KEY, 0.80, float))
        except: v = 0.80
        return max(0.0, min(1.0, v))

    def _set_threshold(self, v: float):
        QSettings().setValue(self.THRESH_KEY, float(v))

    def _get_threshold_enabled(self) -> bool:
        return bool(QSettings().value(self.THRESH_ENABLED_KEY, False, bool))

    def _set_threshold_enabled(self, on: bool):
        QSettings().setValue(self.THRESH_ENABLED_KEY, bool(on))
        self._update_threshold_label()

    def _get_life_basis(self) -> str:
        v = (QSettings().value(self.LIFE_BASIS_KEY, "page", str) or "page").lower()
        return "drive" if v.startswith("d") else "page"

    def _set_life_basis(self, v: str):
        QSettings().setValue(self.LIFE_BASIS_KEY, (v or "page").lower())

    def _load_id_history(self):
        h = QSettings().value(self.HISTORY_KEY, [], list)
        if not isinstance(h, list): h = list(h)
        self._set_history([x for x in h if isinstance(x, str) and x])

    def _save_id_history(self):
        QSettings().setValue(self.HISTORY_KEY, [self._id_combo.itemText(i) for i in range(self._id_combo.count())])

    def _set_history(self, items: list[str]):
        self._id_combo.clear()
        for it in items: self._id_combo.addItem(it)

    def _reset_update_thread(self):
            """
            Clears the python reference to the thread so we don't
            accidentally access a deleted C++ object later.
            """
            self._update_thread = None
            self._update_worker = None

    def _start_update_check(self, silent=False):
        """
        silent=True: Used on startup (only notify if update FOUND).
        silent=False: Used on button click (notify if up-to-date or error).
        """
        # SAFE CHECK: Ensure we don't access a deleted thread
        if self._update_thread is not None:
            if self._update_thread.isRunning():
                if not silent:
                    self.editor.appendPlainText("[Update] Check already in progress...")
                return

        self._update_silent_mode = silent
        if not silent:
            self.editor.appendPlainText("[Info] Checking for updates...")

        self._update_thread = QThread()
        self._update_worker = UpdateWorker()
        self._update_worker.moveToThread(self._update_thread)

        self._update_thread.started.connect(self._update_worker.check_updates)
        self._update_worker.check_finished.connect(self._on_check_finished)
        self._update_worker.error_occurred.connect(self._on_update_error)
        self._update_worker.download_progress.connect(self._on_download_progress)
        self._update_worker.download_finished.connect(self._on_download_complete)

        self._update_worker.check_finished.connect(self._update_thread.quit)
        self._update_worker.error_occurred.connect(self._update_thread.quit)

        self._update_thread.finished.connect(self._update_thread.deleteLater)
        self._update_thread.finished.connect(self._update_thread.deleteLater)
        self._update_thread.finished.connect(self._reset_update_thread)

        self._update_thread.start()

    @pyqtSlot(bool, str, str)
    def _on_check_finished(self, found, version_tag, url):
        self._update_thread.quit() # Stop the check thread

        if found:
            res = CustomMessageBox.confirm(
                self,
                "Update Available",
                f"New version {version_tag} is available.\nDo you want to update now?",
                self._icon_dir
            )
            if res == "ok":
                self._start_download(url)
        else:
            if not self._update_silent_mode:
                CustomMessageBox.info(self, "Up to Date", f"You are on the latest version ({CURRENT_VERSION}).", self._icon_dir)

    @pyqtSlot(str)
    def _on_update_error(self, msg):
        self._update_thread.quit()
        if not self._update_silent_mode:
            self.editor.appendPlainText(f"[Update Error] {msg}")
            CustomMessageBox.warn(self, "Update Error", msg, self._icon_dir)

    def _start_download(self, url):
        self.editor.appendPlainText("[Update] Starting download...")

        self._dl_thread = QThread()
        self._dl_worker = UpdateWorker()
        self._dl_worker.moveToThread(self._dl_thread)

        self.sig_start_download.connect(self._dl_worker.download_update)
        self.sig_start_extract.connect(self._dl_worker.extract_update)

        self._dl_worker.download_progress.connect(self._on_download_progress)
        self._dl_worker.extraction_progress.connect(self._on_download_progress)

        self._dl_worker.download_finished.connect(self._on_download_complete)
        self._dl_worker.extraction_finished.connect(self._on_extraction_complete)
        self._dl_worker.error_occurred.connect(self._on_update_error)

        self._dl_worker.extraction_finished.connect(self._dl_thread.quit)
        self._dl_worker.error_occurred.connect(self._dl_thread.quit)
        self._dl_thread.finished.connect(self._dl_thread.deleteLater)

        self._dl_thread.start()

        self._dl_dialog = FramelessDialog(self, "Updating PmGen", self._icon_dir)
        self._dl_bar = QProgressBar(self._dl_dialog)
        self._dl_bar.setObjectName("ProgressBar")
        self._dl_bar.setRange(0, 100)
        self._dl_bar.setValue(0)

        self._dl_label = QLabel("Downloading Update...", self._dl_dialog)
        self._dl_label.setObjectName("DialogLabel")

        self._dl_dialog._content_layout.addWidget(self._dl_label)
        self._dl_dialog._content_layout.addWidget(self._dl_bar)
        self._dl_dialog.show()

        self.sig_start_download.emit(url)

    @pyqtSlot(int)
    def _on_download_progress(self, pct):
        """Shared slot for both download and extraction progress."""
        if hasattr(self, "_dl_bar"):
            self._dl_bar.setValue(pct)

    @pyqtSlot(str)
    def _on_download_complete(self, zip_path):
        """Switch UI to Extraction mode and start extraction via signal."""
        if hasattr(self, "_dl_label"):
            self._dl_label.setText("Extracting Files...")
        if hasattr(self, "_dl_bar"):
            self._dl_bar.setValue(0)

        self.sig_start_extract.emit(zip_path)

    @pyqtSlot(str, str)
    def _on_extraction_complete(self, zip_path, extract_dir):
        if hasattr(self, "_dl_dialog"):
            self._dl_dialog.close()

        perform_restart(zip_path, extract_dir)

    # =========================================================================
    #  Actions & Logic
    # =========================================================================

    def _update_threshold_label(self):
        if hasattr(self, "_thr_label"):
            txt = "Threshold: 100.0%" if not self._get_threshold_enabled() else f"Threshold: {self._get_threshold() * 100:.1f}%"
            self._thr_label.setText(txt)

    def _update_basis_label(self):
        if hasattr(self, "_basis_label"):
            self._basis_label.setText(f"Basis: {self._get_life_basis().upper()}")

    def _auto_capitalize(self, text: str):
        le = self._id_combo.lineEdit()
        cursor = le.cursorPosition()
        le.blockSignals(True)
        le.setText(text.upper())
        le.setCursorPosition(cursor)
        le.blockSignals(False)

    def _apply_colorized_highlighter(self):
        if not hasattr(self, "_out_highlighter"): self._out_highlighter = None
        want, have = self._get_colorized(), self._out_highlighter is not None
        if want and not have:
            self._out_highlighter = OutputHighlighter(self.editor.document())
        elif not want and have:
            self._out_highlighter.setDocument(None); self._out_highlighter.deleteLater(); self._out_highlighter = None
            self.editor.setPlainText(self.editor.toPlainText())

    @safe_slot
    def _on_generate_clicked(self, *args):
        # Always ensure we are on the Home tab (index 0)
        self.tabs.setCurrentIndex(0)

        le = self._id_combo.lineEdit()
        text = le.text().strip().upper()

        logging.info(f"User requested generation for serial: {text}")

        if not text:
            CustomMessageBox.warn(self, "Missing Serial", "Please Enter A Serial Number", self._icon_dir)
            return

        items = [text] + [self._id_combo.itemText(i) for i in range(self._id_combo.count()) if self._id_combo.itemText(i).upper() != text]
        self._set_history(items[:self.MAX_HISTORY])
        self._save_id_history()

        try: from pmgen.engine.single_report import generate_from_bytes
        except ImportError: from pmgen.engine import generate_from_bytes

        data = None
        unpack_date = None

        try:
            from pmgen.io.http_client import get_service_file_bytes, get_unpacking_date

            # Fetch PM bytes
            data = get_service_file_bytes(text, "PMSupport", sess=self._session)

            # NEW: Fetch unpacking date (optional)
            try:
                unpack_date = get_unpacking_date(text, sess=self._session)
            except Exception as e:
                logging.warning(f"Could not fetch unpacking date for {text}: {e}")

            print("DEBUG: Download finished! Size:", len(data) if data else 0, flush=True)
        except Exception:
            try:
                if hasattr(self, "act_login"): self.act_login.trigger()
                from pmgen.io.http_client import get_service_file_bytes as _refetch
                # Retry fetching report
                data = _refetch(text, "PMSupport")
                # We skip retrying unpack_date here to keep fallback simple/fast
            except Exception as e2:
                CustomMessageBox.warn(self, "Online fetch failed", str(e2), self._icon_dir)

        if data is None:
            path, _ = QFileDialog.getOpenFileName(self, "Open PM Report", "", "PM Export (*.csv *.txt);;All Files (*.*)")
            if not path: return
            with open(path, "rb") as f: data = f.read()

        try:
            out = generate_from_bytes(
                pm_pdf_bytes=data,
                threshold=self._get_threshold(),
                life_basis=self._get_life_basis(),
                show_all=self._get_show_all(),
                threshold_enabled=self._get_threshold_enabled(),
                unpacking_date=unpack_date,
                alerts_enabled=self._get_alerts_enabled()
            )
            self.editor.setPlainText(out)
            self._apply_colorized_highlighter()
            logging.info("Report generation successful.")
        except Exception as e:
            logging.error(f"Generation failed: {e}")
            CustomMessageBox.warn(self, "Generate failed", str(e), self._icon_dir)

    @safe_slot
    def _start_bulk(self, *args):
        # 1. Prepare Config & Args
        cfg = self._get_bulk_config()
        cfg.show_all = self._get_show_all()

        s = QSettings()
        unpack_max_enabled = bool(s.value("bulk/unpack_filter_enabled", False, bool))
        unpack_max_months = int(s.value("bulk/unpack_extra_months", 0, int))
        unpack_min_enabled = bool(s.value("bulk/unpack_min_filter_enabled", False, bool))
        unpack_min_months = int(s.value("bulk/unpack_min_months", 0, int))

        runner_kwargs = {
            "threshold": self._get_threshold(),
            "life_basis": self._get_life_basis(),
            "threshold_enabled": self._get_threshold_enabled(),
            "unpack_max_enabled": unpack_max_enabled,
            "unpack_max_months": unpack_max_months,
            "unpack_min_enabled": unpack_min_enabled,
            "unpack_min_months": unpack_min_months,
        }

        # 2. Create the Tab
        tab = BulkRunTab(cfg, runner_kwargs)

        # 3. Connect Tab Signals to MainWindow Actions
        # When tab requests inspection, fill serial in Home and generate
        tab.inspect_requested.connect(self._on_bulk_inspect_requested)

        # 4. Add to TabWidget and Select it
        title = f"Bulk {datetime.now().strftime('%H:%M')}"
        idx = self.tabs.addTab(tab, title)
        self.tabs.setCurrentIndex(idx)

        # 5. Start the Job
        tab.start()

    @pyqtSlot(str)
    def _on_bulk_inspect_requested(self, serial):
        """Called when a Bulk Tab 'Inspect' context menu is clicked."""
        self.tabs.setCurrentIndex(0) # Go to Home
        self._id_combo.setEditText(serial)
        self._on_generate_clicked()

    def _clear_output_window(self): self.editor.clear()

    # =========================================================================
    #  Dialogs
    # =========================================================================
    @safe_slot
    def _open_due_threshold_dialog(self, *args):
        dlg = FramelessDialog(self, "Optional Threshold", self._icon_dir)
        top = QLabel("Items over 100% life are always DUE.\nOptionally enable a lower due threshold.", dlg)
        top.setObjectName("DialogLabel")

        enable_cb = QCheckBox("Enable Optional threshold", dlg); enable_cb.setObjectName("DialogCheckbox")
        enable_cb.setChecked(self._get_threshold_enabled())

        slider = QSlider(Qt.Orientation.Horizontal, dlg)
        slider.setObjectName("ThresholdSlider")
        slider.setRange(0, 100); slider.setTickInterval(10); slider.setValue(int(self._get_threshold()*100))

        pct_box = QDoubleSpinBox(dlg); pct_box.setObjectName("DialogInput")
        pct_box.setRange(0.0, 100.0); pct_box.setSuffix("%"); pct_box.setValue(self._get_threshold()*100.0)

        slider.setEnabled(enable_cb.isChecked()); pct_box.setEnabled(enable_cb.isChecked())

        enable_cb.toggled.connect(lambda c: (self._set_threshold_enabled(c), slider.setEnabled(c), pct_box.setEnabled(c)))
        slider.valueChanged.connect(lambda v: pct_box.setValue(float(v)))
        pct_box.valueChanged.connect(lambda v: slider.setValue(int(v)))

        save_btn = QPushButton("Save", dlg)
        save_btn.clicked.connect(lambda: (self._set_threshold(pct_box.value()/100.0), self._update_threshold_label(), dlg.accept()))

        dlg._content_layout.addWidget(top); dlg._content_layout.addWidget(enable_cb)
        r1 = QHBoxLayout(); r1.addWidget(slider, 1); r1.addWidget(pct_box); dlg._content_layout.addLayout(r1)
        r2 = QHBoxLayout(); r2.addStretch(1); r2.addWidget(save_btn); dlg._content_layout.addLayout(r2)
        dlg.exec()

    @safe_slot
    def _open_login_dialog(self, *args):
        dlg = FramelessDialog(self, "Login", self._icon_dir)
        u_in = QLineEdit(dlg); u_in.setObjectName("DialogInput"); u_in.setPlaceholderText("Username")
        if (last_user := QSettings().value(self.AUTH_USERNAME_KEY, "", str)): u_in.setText(last_user)
        p_in = QLineEdit(dlg); p_in.setEchoMode(QLineEdit.EchoMode.Password); p_in.setObjectName("DialogInput"); p_in.setPlaceholderText("Password")

        remember = QCheckBox("Stay Logged In", dlg); remember.setObjectName("DialogCheckbox")
        remember.setChecked(bool(QSettings().value(self.AUTH_REMEMBER_KEY, False, bool)))

        btn_login = QPushButton("Login", dlg); btn_login.setDefault(True)

        def _do_login():
            u, p = u_in.text().strip(), p_in.text()
            if not u or not p: return

            logging.info(f"Attempting manual login for user: {u}")

            btn_login.setEnabled(False); self.user_label.setText("Signing in…"); self.editor.appendPlainText(f"[Auto-Login] Attempting as {u}…")
            try:
                from pmgen.io import http_client as hc
                hc.save_credentials(u, p)
                sess = requests.Session()
                hc.login(sess)
                QSettings().setValue(self.AUTH_REMEMBER_KEY, remember.isChecked())
                QSettings().setValue(self.AUTH_USERNAME_KEY, u)
                self._signed_in = True; self._current_user = u; self._update_auth_ui()
                self.editor.appendPlainText(f"[Auto-Login] {u} — success")
                dlg.accept()
            except Exception as e:
                self._signed_in = False; self._current_user = ""; self._update_auth_ui()
                self.editor.appendPlainText(f"[Auto-Login] {u} — failed: {e}")
                CustomMessageBox.warn(self, "Login failed", str(e), self._icon_dir)
            finally: btn_login.setEnabled(True)

        btn_login.clicked.connect(_do_login)
        dlg._content_layout.addWidget(QLabel("Username", dlg)); dlg._content_layout.addWidget(u_in)
        dlg._content_layout.addWidget(QLabel("Password", dlg)); dlg._content_layout.addWidget(p_in)
        row = QHBoxLayout(); row.addWidget(remember); row.addStretch(1); row.addWidget(btn_login)
        dlg._content_layout.addLayout(row); dlg.exec()

    @safe_slot
    def _open_life_basis_dialog(self, *args):
        dlg = FramelessDialog(self, "Life Basis", self._icon_dir)
        lbl = QLabel("Choose counter basis (fallback to other if missing).", dlg); lbl.setObjectName("DialogLabel")
        box = QComboBox(dlg); box.setObjectName("DialogInput"); box.addItems(["Page", "Drive"])
        box.setCurrentIndex(0 if self._get_life_basis() == "page" else 1)
        btn = QPushButton("Save", dlg)
        btn.clicked.connect(lambda: (self._set_life_basis("page" if box.currentIndex()==0 else "drive"), self._update_basis_label(), dlg.accept()))
        dlg._content_layout.addWidget(lbl); dlg._content_layout.addWidget(box)
        r = QHBoxLayout(); r.addStretch(1); r.addWidget(btn); dlg._content_layout.addLayout(r)
        dlg.exec()

    @safe_slot
    def _open_bulk_settings(self, *args):
        cfg = self._get_bulk_config()
        s = QSettings()
        dlg = FramelessDialog(self, "Bulk Settings", self._icon_dir)

        # Build UI rows manually to save vertical space
        def _row(label, widget):
            r = QHBoxLayout()
            r.addWidget(QLabel(label, dlg))
            r.addStretch(1)
            r.addWidget(widget)
            return r

        # --- Standard Config ---
        sp_top = QSpinBox(dlg); sp_top.setObjectName("DialogInput"); sp_top.setRange(1, 9999); sp_top.setValue(cfg.top_n)
        sp_pool = QSpinBox(dlg); sp_pool.setObjectName("DialogInput"); sp_pool.setRange(1, 16); sp_pool.setValue(cfg.pool_size)
        ed_dir = QLineEdit(cfg.out_dir, dlg); ed_dir.setObjectName("DialogInput")
        btn_br = QPushButton("Browse", dlg); btn_br.clicked.connect(lambda: ed_dir.setText(QFileDialog.getExistingDirectory(self, "Out", cfg.out_dir) or cfg.out_dir))

        bl_edit = QPlainTextEdit(dlg); bl_edit.setObjectName("MainEditor"); bl_edit.setFixedHeight(60)
        bl_edit.setPlainText("\n".join(cfg.blacklist or []))

        # --- Date Filters (Max Age / Min Age) ---

        # 1. Max Age (Existing: "Unpack Filter")
        cb_max_age = QCheckBox("Exclude if OLDER than (Months):", dlg); cb_max_age.setObjectName("DialogCheckbox")
        cb_max_age.setChecked(bool(s.value("bulk/unpack_filter_enabled", False, bool)))
        sp_max_age = QSpinBox(dlg); sp_max_age.setObjectName("DialogInput"); sp_max_age.setRange(0, 120)
        sp_max_age.setValue(int(s.value("bulk/unpack_extra_months", 0, int))) # Reusing existing key

        # 2. Min Age (New)
        cb_min_age = QCheckBox("Exclude if NEWER than (Months):", dlg); cb_min_age.setObjectName("DialogCheckbox")
        cb_min_age.setChecked(bool(s.value("bulk/unpack_min_filter_enabled", False, bool)))
        sp_min_age = QSpinBox(dlg); sp_min_age.setObjectName("DialogInput"); sp_min_age.setRange(0, 120)
        sp_min_age.setValue(int(s.value("bulk/unpack_min_months", 0, int)))

        btn_save = QPushButton("Save", dlg)
        def _save():
            bl = [l.strip().upper() for l in re.split(r"[\n,]+", bl_edit.toPlainText()) if l.strip()]
            self._save_bulk_config(BulkConfig(sp_top.value(), ed_dir.text().strip(), sp_pool.value(), bl))

            # Save Max Age (Existing keys)
            s.setValue("bulk/unpack_filter_enabled", cb_max_age.isChecked())
            s.setValue("bulk/unpack_extra_months", sp_max_age.value())

            # Save Min Age (New keys)
            s.setValue("bulk/unpack_min_filter_enabled", cb_min_age.isChecked())
            s.setValue("bulk/unpack_min_months", sp_min_age.value())

            dlg.accept()
        btn_save.clicked.connect(_save)

        l = dlg._content_layout
        l.addLayout(_row("Top N serials:", sp_top))
        l.addLayout(_row("Parallel workers:", sp_pool))

        r_dir = QHBoxLayout(); r_dir.addWidget(QLabel("Out Dir:", dlg)); r_dir.addWidget(ed_dir, 1); r_dir.addWidget(btn_br); l.addLayout(r_dir)

        l.addWidget(QLabel("Blacklist:", dlg)); l.addWidget(bl_edit)

        # Add the two filter rows
        r_min = QHBoxLayout(); r_min.addWidget(cb_min_age); r_min.addStretch(1); r_min.addWidget(sp_min_age); l.addLayout(r_min)
        r_max = QHBoxLayout(); r_max.addWidget(cb_max_age); r_max.addStretch(1); r_max.addWidget(sp_max_age); l.addLayout(r_max)

        r_btn = QHBoxLayout(); r_btn.addStretch(1); r_btn.addWidget(btn_save); l.addLayout(r_btn)
        dlg.exec()

    def _show_about(self):
        from pmgen.catalog.part_kit_catalog import REGISTRY
        models = sorted([k for k, v in REGISTRY.items() if v is not None])
        txt = f"PmGen\nVersion: {CURRENT_VERSION}\nSupported models: {len(models)}\n—\n"
        # Simple columns
        for i in range(0, len(models), 4): txt += "".join(s.ljust(12) for s in models[i:i+4]) + "\n"

        dlg = FramelessDialog(self, "About", self._icon_dir)
        t = QPlainTextEdit(dlg); t.setReadOnly(True); t.setObjectName("MainEditor"); t.setPlainText(txt)
        btn = QPushButton("OK", dlg); btn.clicked.connect(dlg.accept)
        dlg._content_layout.addWidget(t); dlg._content_layout.addWidget(btn)
        dlg.exec()

    # =========================================================================
    #  Auth & Event Logic
    # =========================================================================

    def _attempt_auto_login(self):
        if self._auto_login_attempted or self._signed_in: return
        self._auto_login_attempted = True
        s = QSettings()
        if not bool(s.value(self.AUTH_REMEMBER_KEY, False, bool)): return

        u = s.value(self.AUTH_USERNAME_KEY, "", str)
        if not u: return

        self.user_label.setText("Signing in…"); self.editor.appendPlainText(f"[Auto-Login] Attempting as {u}…")
        try:
            from pmgen.io import http_client as hc
            sess = requests.Session()
            hc.login(sess)
            self._session = sess
            self._signed_in = True; self._current_user = u; self._update_auth_ui()
            self.editor.appendPlainText(f"[Auto-Login] {u} — success")
        except Exception as e:
            self._signed_in = False; self._current_user = ""; self._update_auth_ui()
            self.editor.appendPlainText(f"[Auto-Login] {u} — failed: {e}")

    @safe_slot
    def _logout(self, *args):
        logging.info("User requested logout.")
        QSettings().setValue(self.AUTH_REMEMBER_KEY, False); QSettings().setValue(self.AUTH_USERNAME_KEY, "")
        try:
            from pmgen.io import http_client as hc
            if hasattr(hc, "server_side_logout"): hc.server_side_logout()
            if hasattr(hc, "SessionPool"): hc.SessionPool.close_all_pools()
            hc.clear_credentials()
        except: pass
        self._signed_in = False; self._current_user = ""; self._session = None; self._update_auth_ui(); self.editor.appendPlainText("[Info] - Logout Successful")

    def _update_auth_ui(self):
        self.user_label.setText(self._current_user or "(signed in)" if self._signed_in else "Not signed in")

    def _toggle_fullscreen(self, checked: bool): self.showFullScreen() if checked else self.showNormal()

    def _confirm_exit(self):
        if CustomMessageBox.confirm(self, "Exit", "Are you sure you want to exit?", self._icon_dir) == "ok": self.close()

    def closeEvent(self, ev):
        self._save_id_history()
        super().closeEvent(ev)

    def eventFilter(self, obj, event):
        if not self.isFullScreen() and event.type() in (QEvent.Type.MouseMove, QEvent.Type.HoverMove, QEvent.Type.Leave):
            self._update_cursor(QCursor.pos())
        return super().eventFilter(obj, event)

    def _edge_flags_at_pos(self, pos_global: QPoint):
        pos = self.mapFromGlobal(pos_global); r = self.rect()
        return (pos.x() <= BORDER_WIDTH, pos.x() >= r.width() - BORDER_WIDTH,
                pos.y() <= BORDER_WIDTH, pos.y() >= r.height() - BORDER_WIDTH)

    def _update_cursor(self, pos_global: QPoint):
        if self.isFullScreen(): self.unsetCursor(); return
        left, right, top, bottom = self._edge_flags_at_pos(pos_global)
        if (left and top) or (right and bottom): self.setCursor(Qt.CursorShape.SizeFDiagCursor)
        elif (right and top) or (left and bottom): self.setCursor(Qt.CursorShape.SizeBDiagCursor)
        elif left or right: self.setCursor(Qt.CursorShape.SizeHorCursor)
        elif top or bottom: self.setCursor(Qt.CursorShape.SizeVerCursor)
        else: self.setCursor(Qt.CursorShape.ArrowCursor)

    def mousePressEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton and not self.isFullScreen():
            l, r, t, b = self._edge_flags_at_pos(e.globalPosition().toPoint())
            if any((l, r, t, b)):
                self._rs = ResizeState(True, l, r, t, b, e.globalPosition().toPoint(), self.geometry())
                e.accept(); return
        super().mousePressEvent(e)

    def mouseMoveEvent(self, e):
        if self._rs.resizing and not self.isFullScreen():
            delta = e.globalPosition().toPoint() - self._rs.press_pos
            g = QRect(self._rs.press_geom)
            if self._rs.edge_left: g.setLeft(min(g.left() + delta.x(), g.right() - 200))
            elif self._rs.edge_right: g.setRight(max(self._rs.press_geom.right() + delta.x(), g.left() + 200))
            if self._rs.edge_top: g.setTop(min(g.top() + delta.y(), g.bottom() - 150))
            elif self._rs.edge_bottom: g.setBottom(max(self._rs.press_geom.bottom() + delta.y(), g.top() + 150))
            self.setGeometry(g); e.accept(); return

        if not self.isFullScreen(): self._update_cursor(e.globalPosition().toPoint())
        super().mouseMoveEvent(e)

    def mouseReleaseEvent(self, e):
        if e.button() == Qt.MouseButton.LeftButton and self._rs.resizing:
            self._rs = ResizeState(); self._update_cursor(QCursor.pos()); e.accept(); return
        super().mouseReleaseEvent(e)

    def enterEvent(self, e):
        if not self.isFullScreen(): self._update_cursor(QCursor.pos())
        super().enterEvent(e)

    def leaveEvent(self, e):
        self.unsetCursor()
        super().leaveEvent(e)

==> theme.py
from PyQt6.QtWidgets import QApplication

GLOBAL_STYLE_DARK = """
#TopBarBg { background-color: #202225; }
#MainEditor { background: #1e1f22; color: #e9e9e9; border: 1px solid #000000; font-family: Consolas, "Fira Code", monospace; font-size: 13px; }
QMainWindow { background: #181a1b; }
QLabel#TitleLabel { color: #e9e9e9; font-size: 16pt; font-weight: 500; }

/* Toolbar */
QToolBar { background: transparent; border: none; spacing: 0px; padding: 0 8px; }
QToolButton { border: none; background: transparent; padding: 6px 8px; }
QToolButton:hover { background-color: rgba(127,127,127,0.15); border-radius: 0; }
QToolButton#SettingsBtn, QToolButton#BulkBtn { padding: 6px 10px; border-radius: 0; font-weight: 500; }
QToolButton#SettingsBtn::menu-indicator, QToolButton#BulkBtn::menu-indicator { image: none; width: 0px; }

/* Menus */
QMenu { background: #2a2c2f; color: #e9e9e9; border: 1px solid #3a3d41; }
QMenu::item:selected { background: #3a3d41; }

/* Frameless dialogs */
QDialog#FramelessDialogRoot { background: #1f2023; border: 1px solid #000000; border-radius: 0; }
#DialogTitleBar { background: #202225; border-top-left-radius: 0; border-top-right-radius: 0; }
#DialogTitleLabel { color: #e9e9e9; font-weight: 600; }
#DialogBtn { padding: 6px 10px; border-radius: 0; }
#DialogSeparator { background: #000000; max-height: 1px; min-height: 1px; }
#DialogCheckbox { background: #1f2023; }
#DialogCheckbox::indicator { border: 1px solid #000000; width:16px; height:16px; }
QCheckBox#DialogCheckbox::indicator:checked { background:#1f2023; border:1px solid #000000; image: url(_internal/pmgen/assets/icons/checkmark.svg); }
QCheckBox#DialogCheckbox::indicator:unchecked { image: none; }
#DialogLabel { background: #1f2023; color: #e9e9e9; }
#UserLabel { background: #1f2023; color: #e9e9e9; font-weight: 800 }
#DialogInput { background: #2a2c2f; color: #e9e9e9; border: 1px solid #000000; font-weight: 800; }
#DialogInput:focus { background: #2a2c2f; color: #e9e9e9; border-radius: 0; border: 1px solid #000000; font-weight: 800 }
#DialogInput::up-arrow { image: url(_internal/pmgen/assets/icons/up.svg); }
#DialogInput::down-arrow { image: url(_internal/pmgen/assets/icons/down.svg); }

/* Secondary bar */
#SecondaryBar { background: #202225; border: 1px solid #000000; border-radius: 0; padding: 6px; }

/* Keep support for QLineEdit if used anywhere else */
QLineEdit#IdInput { background: #000000; color: #e9e9e9; border: 1px solid #000000; border-radius: 0; padding: 6px 8px; font-weight: 800 }
QLineEdit#IdInput:focus { border: 1px solid #000000; }

/* Editable combo styling for the recent-serials input */
QComboBox#IdInput {
    border: 1px solid #000000;
    border-radius: 0;
    padding-left: 8px; /* text padding */
    background: #202225; /* Match LineEdit background */
    color: #e9e9e9;
    font-weight: 800;
    selection-background-color: #3a3d41;
}

QComboBox#IdInput QLineEdit {
    background: transparent; /* Let parent color show through */
    color: #e9e9e9;
    border: none;
    padding: 0px; /* Reset padding here, handled by parent */
    font-weight: 800;
}

QComboBox#IdInput::drop-down {
    subcontrol-origin: padding;
    subcontrol-position: top right;
    width: 20px; /* Give it width so we can see the arrow */
    border-left-width: 0px;
    border-left-color: #3a3d41;
    border-left-style: solid;
    border-top-right-radius: 0;
    border-bottom-right-radius: 0;
    background: #2a2c2f; /* Slightly lighter than input for contrast */
}

QComboBox#IdInput::down-arrow {
    image: url(_internal/pmgen/assets/icons/down.svg);
    width: 12px;
    height: 12px;
}

QComboBox#IdInput QAbstractItemView {
    background: #2a2c2f;       /* Dark background for the list */
    border: 1px solid #000000; /* Border around the list */
    color: #e9e9e9;            /* Text color */
    selection-background-color: #3a3d41; /* Hover color */
    selection-color: #ffffff;
    outline: 0;
    padding: 2px;
}

QComboBox#IdInput QAbstractItemView::item {
    min-height: 24px;
    padding: 4px;
}

QComboBox#IdInput QAbstractItemView QScrollBar:vertical {
    background: #1e1f22;
    width: 10px;
}

/* 1. The floating list container */
QAbstractItemView#IdCompleterPopup {
    border: 1px solid #000000;
    background: #2a2c2f; /* Dark background */
    color: #e9e9e9;      /* Text color */
    selection-background-color: #3a3d41; /* Hover/Select color */
    selection-color: #ffffff;
    padding: 2px;
    outline: 0;
}

/* 2. The items inside the list */
QAbstractItemView#IdCompleterPopup::item {
    padding: 4px 8px;
    min-height: 24px;
}

/* 3. The Scrollbar inside the completer */
/* We need to copy your scrollbar styles here specifically for the ID selector */
QAbstractItemView#IdCompleterPopup QScrollBar:vertical {
    border-left: 1px solid #000000;
    background: #1e1f22;
    width: 14px;
    margin: 0px;
}
QAbstractItemView#IdCompleterPopup QScrollBar::handle:vertical {
    background: #44474d;
    min-height: 20px;
    border: 1px solid #000000;
    margin: 2px;
}
QAbstractItemView#IdCompleterPopup QScrollBar::handle:vertical:hover {
    background: #5f636a;
}
QAbstractItemView#IdCompleterPopup QScrollBar::add-line:vertical,
QAbstractItemView#IdCompleterPopup QScrollBar::sub-line:vertical {
    height: 0px;
}
QAbstractItemView#IdCompleterPopup QScrollBar::add-page:vertical,
QAbstractItemView#IdCompleterPopup QScrollBar::sub-page:vertical {
    background: none;
}

QPushButton#GenerateBtn { padding: 6px 12px; border-radius: 0; border: 1px solid #000000; background: #2a2c2f; color: #e9e9e9; }
QPushButton#GenerateBtn:hover { background: #33363b; }

QPushButton { padding: 6px 12px; border-radius: 0; border: 1px solid #000000; background: #2a2c2f; color: #e9e9e9; }
QPushButton:hover { background: #33363b; }
QDoubleSpinBox#DialogInput {
    border: 1px solid #000000;
    background: #2a2c2f;
    color: #ffffff;
    border-radius: 0;
    padding-right: 6px;
    selection-background-color: #000000;
    selection-color: #ffffff;
}

/* Remove both arrow buttons completely */
QDoubleSpinBox#DialogInput::up-button,
QDoubleSpinBox#DialogInput::down-button { width: 0; height: 0; border: none; margin: 0; padding: 0; }

/* Hide arrow icons */
QDoubleSpinBox#DialogInput::up-arrow,
QDoubleSpinBox#DialogInput::down-arrow { image: none; }

/* Disabled state */
QDoubleSpinBox#DialogInput:disabled { color: #8a8d91; background: #191b1e; border-color: #2a2c2f; }

QScrollBar:vertical {
    border-left: 1px solid #000000;
    background: #1e1f22;
    width: 14px;
    margin: 0px;
}
QScrollBar::handle:vertical {
    background: #44474d;
    min-height: 20px;
    border: 1px solid #000000;
    margin: 2px;
}
QScrollBar::handle:vertical:hover { background: #5f636a; }
QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical { height: 0px; }
QScrollBar::add-page:vertical, QScrollBar::sub-page:vertical { background: none; }

#SettingsBtn {
    color: #ffffff;
}
#BulkBtn {
    color: #ffffff;
}

QLabel {
    color: #ffffff;
}

#DialogCheckbox {
    color: #ffffff;
}

QSlider::groove:horizontal#ThresholdSlider {
    border: 1px solid #000000;
    background: #181a1b;
    height: 8px;
    margin: 2px 0;
}

QSlider::handle:horizontal#ThresholdSlider {
    background: #44474d;
    border: 1px solid #000000;
    width: 16px;
    height: 16px;
    margin: -5px 0;
    border-radius: 0;
}

QSlider::handle:horizontal:hover#ThresholdSlider {
    background: #5f636a;
}

QSlider::sub-page:horizontal#ThresholdSlider {
    background: #2a2c2f;
    border: 1px solid #000000;
    height: 8px;
}

QSlider::add-page:horizontal#ThresholdSlider {
    background: #181a1b;
    border: 1px solid #000000;
    height: 8px;
}

QComboBox#DialogInput QAbstractItemView {
    background: #2a2c2f;
    border: 1px solid #000000;
    color: #e9e9e9;
    selection-background-color: #3a3d41;
    selection-color: #ffffff;
    outline: 0;
}

QProgressBar#ProgressBar {
    border: 1px solid #000000;
    background: #1e1f22;
    color: #e9e9e9;
    text-align: center;
    border-radius: 0;
}

QProgressBar#ProgressBar::chunk {
    background-color: #44474d;
    width: 1px;
}

QTabWidget::pane {
    border: 1px solid #000000;
    background: #181a1b;
    margin-top: -1px; /* Overlap border */
}

QTabWidget::tab-bar {
    alignment: left;
}

QTabBar::tab {
    background: #202225;
    color: #888888;
    padding: 8px 20px;
    border: 1px solid #000000;
    border-bottom: none;
    border-top-left-radius: 0px;
    border-top-right-radius: 0px;
    margin-right: 2px;
    font-weight: 600;
}

QTabBar::tab:selected {
    background: #2a2c2f;
    color: #ffffff;
    border-bottom: 1px solid #2a2c2f; /* Mask the pane border */
}

QTabBar::tab:hover:!selected {
    background: #25272a;
    color: #cccccc;
}

QTableView {
    background-color: #1e1f22;
    color: #e9e9e9;
    border: 1px solid #000000;
    gridline-color: #2a2c2f;
    selection-background-color: #3a3d41;
    selection-color: #ffffff;
    alternate-background-color: #232529;
}
QHeaderView::section {
    background-color: #202225;
    color: #e9e9e9;
    padding: 6px;
    border: 1px solid #000000;
    font-weight: bold;
}
QTableCornerButton::section {
    background-color: #202225;
    border: 1px solid #000000;
}

QTableView
{
    border: 1px solid #333;
    gridline-color: #444;
}
QHeaderView::section
{
    background-color: #2d2d2d;
    padding: 4px;
    border: none;
    font-weight: bold;
}
"""

def apply_static_theme(app: QApplication):
    app.setStyle("Fusion")
    app.setStyleSheet(GLOBAL_STYLE_DARK)

==> workers.py
import os
import logging
import traceback
from fnmatch import fnmatchcase
from concurrent.futures import ThreadPoolExecutor, as_completed
from dataclasses import dataclass
from datetime import datetime
from PyQt6.QtCore import QObject, pyqtSignal, QThread

@dataclass
class BulkConfig:
    top_n: int = 25
    out_dir: str = ""
    pool_size: int = 4
    blacklist: list[str] = None
    show_all: bool = False

    def __post_init__(self):
        if self.blacklist is None: self.blacklist = []

class BulkRunner(QObject):
    progress = pyqtSignal(str)
    progress_value = pyqtSignal(int, int)
    finished = pyqtSignal(str)
    # Signal Signature: (Serial, Status, Result, Model, UnpackDate)
    item_updated = pyqtSignal(str, str, str, str, str)

    def __init__(self, cfg: BulkConfig, threshold: float, life_basis: str,
                 threshold_enabled: bool = True,
                 unpack_max_enabled: bool = False, unpack_max_months: int = 0,
                 unpack_min_enabled: bool = False, unpack_min_months: int = 0):
        super().__init__()
        self.cfg = cfg
        self.threshold = threshold
        self.life_basis = life_basis
        self.threshold_enabled = bool(threshold_enabled)
        self._blacklist = [p.upper() for p in (cfg.blacklist or [])]

        self._unpack_max_enabled = bool(unpack_max_enabled)
        self._unpack_max_months = max(0, min(120, int(unpack_max_months)))
        self._unpack_min_enabled = bool(unpack_min_enabled)
        self._unpack_min_months = max(0, min(120, int(unpack_min_months)))

    def _update_pool_progress(self, current, total):
        self.progress.emit(f"[Info] Creating session pool ({current}/{total})...")

    def _is_blacklisted(self, serial: str) -> bool:
        s = (serial or "").upper()
        for pat in (self._blacklist or []):
            if fnmatchcase(s, pat): return True
        return False

    def _prefilter_by_unpack_date(self, serials: list[str], pool) -> list[str]:
        if not self._unpack_max_enabled and not self._unpack_min_enabled:
            self.progress.emit("[Info] Unpack date filters disabled.")
            return list(serials)

        try:
            from pmgen.io.http_client import get_device_info_08
            _use_combined = True
        except ImportError:
            from pmgen.io.http_client import get_unpacking_date as _get_unpack
            _use_combined = False

        from datetime import date
        import calendar

        def _add_months(d: date, months: int) -> date:
            y = d.year + (d.month - 1 + months) // 12
            m = (d.month - 1 + months) % 12 + 1
            return date(y, m, min(d.day, calendar.monthrange(y, m)[1]))

        kept = []

        self.progress.emit("[Bulk] Fetching dates for pre-filtering...")

        with pool.acquire() as sess:
            total = len(serials)
            count = 0
            today = date.today()

            for s in serials:
                # CHANGE 2: Check for stop signal during pre-filtering
                if QThread.currentThread().isInterruptionRequested():
                    self.progress.emit("[Info] Date check stopped by user.")
                    return kept

                count += 1
                self.progress_value.emit(count, total)

                if count % 5 == 0:
                    self.progress.emit(f"[Bulk] Checking dates... ({count}/{total})")

                d = None
                model = "Unknown"

                try:
                    if _use_combined:
                        info = get_device_info_08(s, sess=sess)
                        d = info.get("date")
                        model = info.get("model", "Unknown")
                    else:
                        d = _get_unpack(s, sess=sess)
                except Exception:
                    kept.append(s)
                    continue

                if model and model != "Unknown":
                     self.item_updated.emit(s, "Queued", "", model, "")

                if not d:
                    kept.append(s)
                    continue

                d_str = d.strftime("%Y-%m-%d")

                # Max Age Check
                if self._unpack_max_enabled:
                    cutoff_max = _add_months(d, self._unpack_max_months)
                    if today > cutoff_max:
                        self.item_updated.emit(s, "Filtered", "Too Old", model, d_str)
                        continue

                # Min Age Check
                if self._unpack_min_enabled:
                    cutoff_min = _add_months(d, self._unpack_min_months)
                    if today < cutoff_min:
                        self.item_updated.emit(s, "Filtered", "Too New", model, d_str)
                        continue

                kept.append(s)

        return kept

    def _fmt_pct(self, p):
        if p is None: return "—"
        try: return f"{(float(p) * 100):.1f}%"
        except Exception: return "—"

    def run(self):
        pool = None
        try:
            if not self.cfg.out_dir or not self.cfg.out_dir.strip():
                raise ValueError("Output directory is not set.")

            date_str = datetime.now().strftime("%Y-%m-%d")
            base_path = os.path.join(self.cfg.out_dir, date_str)
            final_out_dir = base_path
            counter = 1
            while os.path.exists(final_out_dir):
                final_out_dir = f"{base_path} ({counter})"
                counter += 1
            os.makedirs(final_out_dir, exist_ok=True)

            from pmgen.io.http_client import SessionPool, get_serials_after_login, get_service_file_bytes, get_unpacking_date
            from pmgen.parsing.parse_pm_report import parse_pm_report
            from pmgen.engine.run_rules import run_rules
            from pmgen.engine.single_report import create_pdf_report
            from pmgen.engine.final_report import write_final_summary_pdf

            pool_size = self.cfg.pool_size
            self.progress.emit(f"[Info] Initializing {pool_size} sessions...")

            try:
                pool = SessionPool(pool_size, callback=self._update_pool_progress)

            except Exception as e:
                self.progress.emit(f"[Info] Failed to create pool: {e}")
                return

            with pool.acquire() as sess:
                serials = get_serials_after_login(sess)

            self.progress.emit(f"[Info] Found {len(serials)} Active Serials.")

            serials0 = list(serials or [])
            serials1 = [s for s in serials0 if not self._is_blacklisted(s)]

            for s in serials1:
                self.item_updated.emit(s, "Queued", "", "Unknown", "")

            kept_serials = self._prefilter_by_unpack_date(serials1, pool)

            # Stop check in case user stopped during pre-filter
            if QThread.currentThread().isInterruptionRequested():
                self.finished.emit("[Info] Stopped.")
                return

            self.progress.emit(f"[Info] Processing {len(kept_serials)} Serials...")

            thr = self.threshold
            basis = self.life_basis
            show_all = self.cfg.show_all
            thr_enabled = self.threshold_enabled

            def get_val(item, key, default=0.0):
                val = getattr(item, key, None)
                if val is not None: return val
                if isinstance(item, dict): return item.get(key, default)
                return default

            def work(serial: str):
                self.item_updated.emit(serial, "Processing", "...", "", "")
                try:
                    with pool.acquire() as sess:
                        blob = get_service_file_bytes(serial, "PMSupport", sess=sess)
                        unpack_date = get_unpacking_date(serial, sess=sess)

                    report = parse_pm_report(blob)
                    model_name = (report.headers or {}).get("model") or "Unknown"

                    selection = run_rules(report, threshold=thr, life_basis=basis, threshold_enabled=thr_enabled)

                    meta = getattr(selection, "meta", {}) or {}
                    all_items = meta.get("all_items", []) or meta.get("all", []) or getattr(selection, "all_items", []) or []
                    best_used = max([float(get_val(f, "life_used", 0.0) or 0.0) for f in all_items], default=0.0)

                    create_pdf_report(
                        report=report, selection=selection, threshold=thr, life_basis=basis,
                        show_all=show_all, out_dir=final_out_dir, threshold_enabled=thr_enabled,
                        unpacking_date=unpack_date
                    )

                    pct_str = self._fmt_pct(best_used)
                    d_str = unpack_date.strftime("%Y-%m-%d") if unpack_date else ""

                    self.item_updated.emit(serial, "Done", pct_str, model_name, d_str)

                    return {
                        "serial": (report.headers or {}).get("serial") or serial,
                        "model": model_name,
                        "best_used": float(best_used),
                        "text": "None",
                        "grouped": meta.get("selection_pn_grouped", {}) or {},
                        "flat": meta.get("selection_pn", {}) or {},
                        "kit_by_pn": meta.get("kit_by_pn", {}) or {},
                        "due_sources": meta.get("due_sources", {}) or {},
                        "unpacking_date": unpack_date
                    }
                except Exception as e:
                    self.item_updated.emit(serial, "Failed", str(e), "", "")
                    return {"serial": serial, "error": str(e), "trace": traceback.format_exc()}

            results = []
            completed_count = 0
            total_work = len(kept_serials)

            if total_work > 0:
                with ThreadPoolExecutor(max_workers=self.cfg.pool_size) as ex:
                    futures = {ex.submit(work, s): s for s in kept_serials}

                    for fut in as_completed(futures):
                        # CHANGE 3: Check for stop signal inside main loop
                        if QThread.currentThread().isInterruptionRequested():
                            self.progress.emit("[Info] Stop requested. Cancelling pending tasks...")
                            # Cancel any tasks that haven't started yet
                            for f in futures:
                                f.cancel()
                            break

                        s = futures[fut]
                        completed_count += 1
                        self.progress_value.emit(completed_count, total_work)

                        try:
                            res = fut.result()
                            if "error" in res:
                                self.progress.emit(f"[Bulk] {s}: ERROR — {res['error']}")
                            else:
                                self.progress.emit(f"[Bulk] {s}: OK — {self._fmt_pct(res['best_used'])}")
                            results.append(res)
                        except Exception as e:
                            self.progress.emit(f"[Bulk] {s}: CRITICAL — {e}")
            else:
                self.progress.emit("[Info] No serials to process after filtering.")

            # If stopped, we still generate reports for whatever finished
            if QThread.currentThread().isInterruptionRequested():
                 self.finished.emit("[Info] Process Stopped by User.")
                 return

            ok = [r for r in results if "error" not in r]
            ok.sort(key=lambda r: (r.get("best_used") or 0.0), reverse=True)
            top = ok[: self.cfg.top_n]

            if len(top) > 0:
                self.progress.emit(f"[Info] Wrote {len(top)} report files to: {final_out_dir}")
                try:
                    pdf_path = write_final_summary_pdf(
                        out_dir=final_out_dir, results=results, top=top, thr=thr, basis=basis,
                        filename="Final_Summary.pdf", threshold_enabled=thr_enabled
                    )
                    self.finished.emit(f"[Info] Complete. Summary written to: {pdf_path}")
                except Exception as e:
                    self.finished.emit(f"[Info] Reports generated, but Summary PDF failed: {e}")
            else:
                self.finished.emit("[Info] Complete (No valid reports generated).")

        except Exception as e:
            self.finished.emit(f"[Info] Failed: {e}")
            traceback.print_exc()
        finally:
            if pool:
                try: pool.close()
                except: pass

==> __init__.py
from .main_window import SERVICE_NAME
from .inventory import load_inventory_cache
